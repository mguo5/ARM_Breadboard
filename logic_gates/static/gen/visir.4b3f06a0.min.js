var visir = visir || {};

function extend(Child, Parent) {
  Child.prototype = inherit(Parent.prototype)
  Child.prototype.constructor = Child
  Child.parent = Parent.prototype
}

function inherit(proto) {
  function F() {}
  F.prototype = proto
  return new F
}

function trace(msg)
{
	$("#logwindow").append(msg + "<br/>");
	if (window.console && console.log) console.log(msg);
}

function setRotation(elem, deg)
{
	var rotateCSS = 'rotate(' + deg + 'deg)';
	elem.css({
		'transform': rotateCSS
		,'-moz-transform': rotateCSS
		,'-webkit-transform': rotateCSS
	});
}

function AddXMLValue(where, name, value) {
	where.append('<' + name + ' value="'+ value + '"/>');
}

visir.LightNum = function(strnum, digit) {
	var out = "";
	
	var idx = 0;
	for(var i=strnum.length - 1; i >= 0; i--)
	{
		if (strnum[i] == "." || strnum[i] == "-") {
			out = strnum[i] + out;
			continue;
		}
		
		if (idx == digit) {
			out = '<span class="green">'+ strnum[i] + '</span>' + out;
		} else {
			out = strnum[i] + out;
		}
		idx++;
	}
	
	return out;
}

function base64_decode(data) {
  var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
    ac = 0,
    dec = "",
    tmp_arr = [];

  if (!data) {
    return data;
  }

	data = data.replace(/[^A-Za-z0-9\+\/\=]/g, "");

  do {
    h1 = b64.indexOf(data.charAt(i++));
    h2 = b64.indexOf(data.charAt(i++));
    h3 = b64.indexOf(data.charAt(i++));
    h4 = b64.indexOf(data.charAt(i++));

    bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

    o1 = bits >> 16 & 0xff;
    o2 = bits >> 8 & 0xff;
    o3 = bits & 0xff;

		tmp_arr[ac++] = o1;
		if (h3 != 64) tmp_arr[ac++] = o2;
		if (h4 != 64) tmp_arr[ac++] = o3;
  } while (i < data.length);

  return tmp_arr;
}

visir.GetUnit = function(val)
{
	var units = [
		["G", 6 ]
		, ["M", 6 ]
		, ["k", 3 ]
		, ["", 0]
		, ["m", -3]
		, ["u", -6]
		, ["n", -9]
		];
	val = Math.abs(val);
	var unit = "";
	var div = 0;
	if (val == 0) return { unit: unit, pow: div };
	
	for (var key in units) {
		var unit = units[key];
		if (val >= Math.pow(10, unit[1])) {
			return {unit: unit[0], pow: unit[1] };
		}
	}
	
	var last = units[units.length - 1];
	return {unit: last[0], pow: last[1] };
}

var visir = visir || {};

/* XXX: this might be removed and replaced with a better interface, look out for changes */

visir.ExtServices = function(props)
{
	var options = $.extend({
		MakeMeasurement: function() {}
	}, props || {});

	this._options = options;
	this._listeners = [];
}

visir.ExtServices.prototype.MakeMeasurement = function()
{
	trace("ExtServices::MakeMeasurement");
	this._options.MakeMeasurement();
}; /* Important ";" to avoid issues when creating a bundle */

(function( $ ){
	var methods = {
		init : function( props ) {
			var options = $.extend({
				offset: 0,
				turn: function(elem, deg){ return deg; }
				}, props || {});
			
			return this.each(function(){

				var doc = $(document);
				var handle = $(this);
				var top = handle.find(".top");
				
				var newTouch = true;

				handle.on("mousedown touchstart", function(e) {

					e.preventDefault();
					
					// try to avoid having to calculate the size and offset of the turnable each move event
					var offset = handle.offset();
					var center = { x: top.width() / 2, y: top.height() / 2 };
					var origin = top.css("transform-origin");
					if (origin) {
						var sp = origin.split(" ");
						center.x = parseInt(sp[0]);
						center.y = parseInt(sp[1]);
					}					

					doc.on("mousemove.rem touchmove.rem", function(e) {

						e = (e.originalEvent.touches) ? e.originalEvent.touches[0] : e;

						/*
						var offset = handle.offset();
						var center = { x: top.width() / 2, y: top.height() / 2 };
						var origin = top.css("transform-origin");
						if (origin) {
							var sp = origin.split(" ");
							center.x = parseInt(sp[0]);
							center.y = parseInt(sp[1]);
						}
						*/
						var dx = e.pageX - offset.left - center.x;
						var dy = e.pageY - offset.top - center.y;

						var deg = Math.atan2(dy, dx) * 180 / Math.PI;
						deg = (deg + 360) % 360;
						var userdeg = options.turn(handle, deg, newTouch);
						if (userdeg != undefined) {
							setRotation(top, userdeg + options.offset); // XXX: not portable..
						}
						
						newTouch = false;
					});

					doc.on("mouseup.rem touchend.rem", function(e) {
						handle.off(".rem");
						doc.off(".rem");
						newTouch = true;
					});
				});

			});
		},
		destroy : function( ) {
			return this.each(function(){
			});
		}


	};

	$.fn.turnable = function( method ) {

		if ( methods[method] ) {
			return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));
		} else if ( typeof method === 'object' || ! method ) {
			return methods.init.apply( this, arguments );
		} else {
			$.error( 'Method ' +  method + ' does not exist on jQuery.turnable' );
		}    

	};

})( jQuery );
(function( $ ){
	var methods = {
		init : function( props ) {
			var options = $.extend({
				offset: 0,
				move: function(elem, x, y, newtouch){ }
				}, props || {});
			
			return this.each(function(){

				var doc = $(document);
				var handle = $(this);
				//var top = handle.find(".top");
				
				var newTouch = true;

				handle.on("mousedown touchstart", function(e) {

					e.preventDefault();
					
					// try to avoid having to calculate the size and offset of the turnable each move event
					var offset = handle.offset();
					/*var center = { x: top.width() / 2, y: top.height() / 2 };
					var origin = top.css("transform-origin");
					if (origin) {
						var sp = origin.split(" ");
						center.x = parseInt(sp[0]);
						center.y = parseInt(sp[1]);
					}	*/				

					doc.on("mousemove.rem touchmove.rem", function(e) {

						e = (e.originalEvent.touches) ? e.originalEvent.touches[0] : e;
						
						var offset = handle.parent().offset();

						var dx = e.pageX - offset.left;
						var dy = e.pageY - offset.top;
						
						//trace("dx/dy: " + dx + " " + dy);
						
						var p = options.move(handle, dx, dy, newTouch);
						//trace("p: " + p.x + " " + p.y);
						if (p.x != undefined) handle.css("left", p.x + "px");
						if (p.y != undefined) handle.css("top", p.y + "px");

						/*var deg = Math.atan2(dy, dx) * 180 / Math.PI;
						deg = (deg + 360) % 360;
						var userdeg = options.turn(handle, deg, newTouch);
						if (userdeg != undefined) {
							setRotation(top, userdeg + options.offset); // XXX: not portable..
						}*/
						
						newTouch = false;
					});

					doc.on("mouseup.rem touchend.rem", function(e) {
						handle.off(".rem");
						doc.off(".rem");
						newTouch = true;
					});
				});

			});
		},
		destroy : function( ) {
			return this.each(function(){
			});
		}


	};

	$.fn.draggable = function( method ) {

		if ( methods[method] ) {
			return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));
		} else if ( typeof method === 'object' || ! method ) {
			return methods.init.apply( this, arguments );
		} else {
			$.error( 'Method ' +  method + ' does not exist on jQuery.draggable' );
		}    

	};

})( jQuery );

(function( $ ){
	
	function _isInBounds(touch, $elem) {
		var offset = $elem.offset(),
		width = $elem.outerWidth(),
		height = $elem.outerHeight(),
		left = offset.left,
		right = left + width,
		top = offset.top,
		bottom = top + height,
		touchX = touch.pageX,
		touchY = touch.pageY;

		return (touchX > left && touchX < right && touchY > top && touchY < bottom);
	}

	var BUTTON_DOWN = true;
	var BUTTON_UP = false;
	function _setButtonState($button, down) {
		if (down) {
			$button.find("img.up").removeClass("active");
			$button.find("img.down").addClass("active");
		} else {
			$button.find("img.down").removeClass("active");
			$button.find("img.up").addClass("active");
		}
	}
	
	var methods = {
		init : function( props ) {
			var options = $.extend({
				}, props || {});
			
			return this.each(function() {
					var $doc = $(document);
					var $button = $(this);
					var isTouched = false;
					var hasSentClick = false;
										
					$button.on("click", function(e) {
						//trace("click sent")
						hasSentClick = true;
						return false;
					});
						
					$button.on("mousedown touchstart", function(e) {
						//trace("mousedown: " + e.type + " " + e.target.nodeName + " " + e.target.getAttribute("class") + " " + e.target.getAttribute("src"));
						e.preventDefault();
						
						hasSentClick = false;
						
						_setButtonState($button, BUTTON_DOWN);
		
						isTouched = true;
		
						$button.on("mouseover.rem", function(e) {
							_setButtonState($button, BUTTON_DOWN);
							isTouched = true;
						});

						$button.on("mouseout.rem touchleave.rem", function(e) {
							_setButtonState($button, BUTTON_UP);
							isTouched = false;
						});
		
						$doc.on("mousemove.rem touchmove.rem", function(e) {							
							e = (e.originalEvent.touches) ? e.originalEvent.touches[0] : e;
							// check if the finger is still inside
			
							isTouched = _isInBounds(e, $button);
							if (isTouched) {
								_setButtonState($button, BUTTON_DOWN);
							} else {
								_setButtonState($button, BUTTON_UP);
							}
						});
						
						$doc.on("mouseup.rem", function(e) {
							//trace("mouseup.rem: " + e.type + " " + e.target.nodeName + " " + e.target.getAttribute("class") + " " + e.target.getAttribute("src"));
							_setButtonState($button, BUTTON_UP);
							$button.off(".rem");
							$doc.off(".rem");
							
							setTimeout( function() {
								if (isTouched && !hasSentClick) {
									trace("delayed click");
									$button.click();
								}
							}, 10);
							
							return false;
						});

						$doc.on("touchend.rem", function(e) {
							//trace("touchend.rem: " + e.type);
							_setButtonState($button, BUTTON_UP);
							$button.off(".rem");
							$doc.off(".rem");

								// Generate event if mouse or touch is inside the component
							if (isTouched && e.type != "mouseup") {
								$button.click();
								// guarantee that just one event will be sent, even if a browser handles both mouseup and touchend
								isTouched = false;
							}
						});
					});
			});
		},
		destroy : function( ) {
			return this.each(function(){
			});
		}

	};

	$.fn.updownButton = function( method ) {

		if ( methods[method] ) {
			return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));
		} else if ( typeof method === 'object' || ! method ) {
			return methods.init.apply( this, arguments );
		} else {
			$.error( 'Method ' +  method + ' does not exist on jQuery.updownButton' );
		}    

	};

})( jQuery );
var visir = visir || {};

visir.ConfigClass = function()
{
	this._teacherMode = true;
	this._instrReg = null;
	this._manualInstConfig = null;
	this._readOnly = false;
	this._dcPower25 = true;
	this._dcPowerM25 = true;
	this._dcPower6 = true;
	this._unrFormat = false; // Support Universidad Nacional de Rosario format
	this._libraryXml = null;
	this._maxOscMeasureCount = 10;
	this._displayManuals = true;
	this._cacheBuster = null;
	this._vppInFuncgen = true;
	this._disableLoadSave = true;

	var base = "";
	if (visir.BaseLocation) base = visir.BaseLocation;
}

visir.ConfigClass.prototype.GetDeferredConfigLoader = function(configUrlOrObject)
{
	var me = this;

	var def = $.Deferred();

	if (typeof(configUrlOrObject) === 'object') {
		me.ReadConfig(configUrlOrObject);
		def.resolve();
	} else {
		var url = configUrlOrObject;
		if (!url.endsWith(".json")) {
			url = url + "config.json";
		}
		$.get(url, function(data) {
			me.ReadConfig(data);
		}, "json")
		.error( function(obj, msg) {
			alert("failed to read config.json. " + msg);
		}).always( function() {
			def.resolve();
		});
	}
	return def;
}

visir.ConfigClass.prototype.ReadConfig = function(config)
{
	this._teacherMode = config.teacherMode;
	this._instrReg = config.instrReg;
	this._locale = config.locale;
	this._mesServer = config.mesServer;
	this._readOnly = config.readOnly;
	this._transMethod = config.transMethod;
	this._oscRunnable = config.oscRunnable;
	this._libraryXml = (config.libraryXml !== undefined)?config.libraryXml:null;
	this._maxOscMeasureCount = (config.maxOscMeasureCount !== undefined)?config.maxOscMeasureCount:10;
	this._dcPower25 = (config.dcPower25 !== undefined)?config.dcPower25:true;
	this._dcPowerM25 = (config.dcPowerM25 !== undefined)?config.dcPowerM25:true;
	this._dcPower6 = (config.dcPower6 !== undefined)?config.dcPower6:true;
	this._displayManuals = (config.displayManuals !== undefined)?config.displayManuals:true;
	this._cacheBuster = (config.cacheBuster !== undefined)?config.cacheBuster:null;
	this._unrFormat = (config.unrFormat !== undefined)?config.unrFormat:false;
	this._vppInFuncgen = (config.vppInFuncgen !== undefined)?config.vppInFuncgen:true;
	this._disableLoadSave = (config.disableLoadSave !== undefined)?config.disableLoadSave:false;
}

visir.ConfigClass.prototype.Get = function(name)
{
	switch(name) {
		case "teacher": return this._teacherMode;
		case "locale": return this._locale;
		case "mesServer": return this._mesServer;
		case "readOnly": return this._readOnly;
		case "transMethod": return this._transMethod;
		case "oscRunnable": return this._oscRunnable;
		case "maxOscMeasureCount": return this._maxOscMeasureCount;
		case "libraryXml": return this._libraryXml;
		case "dcPower25": return this._dcPower25;
		case "dcPowerM25": return this._dcPowerM25;
		case "dcPower6": return this._dcPower6;
		case "displayManuals": return this._displayManuals;
		case "cacheBuster": return this._cacheBuster;
		case "unrFormat": return this._unrFormat;
		case "vppInFuncgen": return this._vppInFuncgen;
		case "disableLoadSave": return this._disableLoadSave;
	}

	return undefined;
}

visir.ConfigClass.prototype.Set = function(name, value)
{
	switch(name) {
		case "teacher": 
			this._teacherMode = value;
			break;
		case "locale": 
			this._locale = value;
			break;
		case "mesServer": 
			this._mesServer = value;
			break;
		case "readOnly": 
			this._readOnly = value;
			break;
		case "transMethod": 
			this._transMethod = value;
			break;
		case "oscRunnable": 
			this._oscRunnable = value;
			break;
		case "maxOscMeasureCount": 
			this._maxOscMeasureCount = value;
			break;
		case "libraryXml": 
			this._libraryXml = value;
			break;
		case "dcPower25": 
			this._dcPower25 = value;
			break;
		case "dcPowerM25": 
			this._dcPowerM25 = value;
			break;
		case "dcPower6": 
			this._dcPower6 = value;
			break;
		case "displayManuals": 
			this._displayManuals = value;
			break;
		case "cacheBuster": 
			this._cacheBuster = value;
			break;
		case "unrFormat": 
			this._unrFormat = value;
			break;
		case "vppInFuncgen":
			this._vppInFuncgen = value;
			break;
		case "disableLoadSave":
			this._disableLoadSave = value;
			break;

	}
}

visir.ConfigClass.prototype.SetInstrRegistry = function(registry)
{
	this._instrReg = registry;
}

visir.ConfigClass.prototype.SetManualInstrConfig = function(instrmap)
{
	this._manualInstConfig = instrmap;
}

visir.ConfigClass.prototype.GetNrInstrOfType = function(type)
{
	if (this._manualInstConfig) return this._manualInstConfig[type];
	if (this._instrReg) return this._instrReg.GetNrInstrOfType(type);
	return 1;
}

visir.Config = new visir.ConfigClass();

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob&&navigator.msSaveOrOpenBlob.bind(navigator)||function(view){"use strict";if(typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var doc=view.document,get_URL=function(){return view.URL||view.webkitURL||view},save_link=doc.createElementNS("http://www.w3.org/1999/xhtml","a"),can_use_save_link="download"in save_link,click=function(node){var event=doc.createEvent("MouseEvents");event.initMouseEvent("click",true,false,view,0,0,0,0,0,false,false,false,false,0,null);node.dispatchEvent(event)},webkit_req_fs=view.webkitRequestFileSystem,req_fs=view.requestFileSystem||webkit_req_fs||view.mozRequestFileSystem,throw_outside=function(ex){(view.setImmediate||view.setTimeout)(function(){throw ex},0)},force_saveable_type="application/octet-stream",fs_min_size=0,arbitrary_revoke_timeout=500,revoke=function(file){var revoker=function(){if(typeof file==="string"){get_URL().revokeObjectURL(file)}else{file.remove()}};if(view.chrome){revoker()}else{setTimeout(revoker,arbitrary_revoke_timeout)}},dispatch=function(filesaver,event_types,event){event_types=[].concat(event_types);var i=event_types.length;while(i--){var listener=filesaver["on"+event_types[i]];if(typeof listener==="function"){try{listener.call(filesaver,event||filesaver)}catch(ex){throw_outside(ex)}}}},FileSaver=function(blob,name){var filesaver=this,type=blob.type,blob_changed=false,object_url,target_view,dispatch_all=function(){dispatch(filesaver,"writestart progress write writeend".split(" "))},fs_error=function(){if(blob_changed||!object_url){object_url=get_URL().createObjectURL(blob)}if(target_view){target_view.location.href=object_url}else{var new_tab=view.open(object_url,"_blank");if(new_tab==undefined&&typeof safari!=="undefined"){view.location.href=object_url}}filesaver.readyState=filesaver.DONE;dispatch_all();revoke(object_url)},abortable=function(func){return function(){if(filesaver.readyState!==filesaver.DONE){return func.apply(this,arguments)}}},create_if_not_found={create:true,exclusive:false},slice;filesaver.readyState=filesaver.INIT;if(!name){name="download"}if(can_use_save_link){object_url=get_URL().createObjectURL(blob);save_link.href=object_url;save_link.download=name;click(save_link);filesaver.readyState=filesaver.DONE;dispatch_all();revoke(object_url);return}if(view.chrome&&type&&type!==force_saveable_type){slice=blob.slice||blob.webkitSlice;blob=slice.call(blob,0,blob.size,force_saveable_type);blob_changed=true}if(webkit_req_fs&&name!=="download"){name+=".download"}if(type===force_saveable_type||webkit_req_fs){target_view=view}if(!req_fs){fs_error();return}fs_min_size+=blob.size;req_fs(view.TEMPORARY,fs_min_size,abortable(function(fs){fs.root.getDirectory("saved",create_if_not_found,abortable(function(dir){var save=function(){dir.getFile(name,create_if_not_found,abortable(function(file){file.createWriter(abortable(function(writer){writer.onwriteend=function(event){target_view.location.href=file.toURL();filesaver.readyState=filesaver.DONE;dispatch(filesaver,"writeend",event);revoke(file)};writer.onerror=function(){var error=writer.error;if(error.code!==error.ABORT_ERR){fs_error()}};"writestart progress write abort".split(" ").forEach(function(event){writer["on"+event]=filesaver["on"+event]});writer.write(blob);filesaver.abort=function(){writer.abort();filesaver.readyState=filesaver.DONE};filesaver.readyState=filesaver.WRITING}),fs_error)}),fs_error)};dir.getFile(name,{create:false},abortable(function(file){file.remove();save()}),abortable(function(ex){if(ex.code===ex.NOT_FOUND_ERR){save()}else{fs_error()}}))}),fs_error)}),fs_error)},FS_proto=FileSaver.prototype,saveAs=function(blob,name){return new FileSaver(blob,name)};FS_proto.abort=function(){var filesaver=this;filesaver.readyState=filesaver.DONE;dispatch(filesaver,"abort")};FS_proto.readyState=FS_proto.INIT=0;FS_proto.WRITING=1;FS_proto.DONE=2;FS_proto.error=FS_proto.onwritestart=FS_proto.onprogress=FS_proto.onwrite=FS_proto.onabort=FS_proto.onerror=FS_proto.onwriteend=null;return saveAs}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!=null){define([],function(){return saveAs})}

var visir = visir || {};

visir.Language = function()
{
	var locale = visir.Config.Get('locale');

	if ($.inArray(locale, ["en_UK", "es_ES", "pt_BR"]) === -1)
	{
		locale = "en_UK";
	}

	strings = {};
	
	var baseurl = visir.BaseLocation || "";

	$.ajax({
		async: false,
		dataType: "json",
		url: baseurl + '_locales/'+locale+'/messages.json'
	}).done(function(data)
	{
		strings = data;
	});

	this._strings = strings;
}

visir.Language.prototype.GetMessage = function(key)
{
	return this._strings[key].message;
}

visir.Language.prototype.GetDescription = function(key)
{
	return this._strings[key].description;
}

visir.Lang = new visir.Language();
var visir = visir || {};

visir.InstrumentRegistry = function(extService)
{
	this._instruments = [];
	this._registeredTypes = {
		circuit: 0,
		dcpower: 0,
		functiongenerator: 0,
		multimeter: 0,
		oscilloscope: 0
	};
	this._listeners = [];

	function InstrInfo(type, name, swf) { return { type: type, displayname: name, swf: swf } };
	this._instrumentInfo = {
		AgilentOscilloscope: InstrInfo("oscilloscope", visir.Lang.GetMessage("oscilloscope"), "oscilloscope/oscilloscope.swf")
		, Breadboard: InstrInfo("circuit", visir.Lang.GetMessage("breadboard"), "breadboard/breadboard.swf")
		, FlukeMultimeter: InstrInfo("multimeter", visir.Lang.GetMessage("multimeter"), "multimeter/multimeter.swf")
		, HPFunctionGenerator: InstrInfo("functiongenerator", visir.Lang.GetMessage("func_gen"), "functiongenerator/functiongenerator.swf")
		, NationalInstrumentOscilloscope: InstrInfo("oscilloscope", visir.Lang.GetMessage("oscilloscope"), "")
		, TripleDC: InstrInfo("dcpower", visir.Lang.GetMessage("dc_power"), "tripledc/tripledc.swf")
	}

	this._extServices = extService || null;

	if (visir.Config) visir.Config.SetInstrRegistry(this); // XXX: maybe this need to be more configurable..
}

visir.InstrumentRegistry.prototype._Reset = function()
{
	this._instruments = [];
	this._registeredTypes = {
		circuit: 0,
		dcpower: 0,
		functiongenerator: 0,
		multimeter: 0,
		oscilloscope: 0
	};
}

visir.InstrumentRegistry.prototype.CreateInstrument = function()
{
	function construct(constructor, args) {
		function F() {
			return constructor.apply(this, args);
		}
		F.prototype = constructor.prototype;
		return new F();
	}

	if (arguments.length < 2) throw "Invalid number of arguments to CreateInstrument";
	var name = arguments[0];
	var id = this._NextInstrID(name);
	arguments[0] = id; // replace the first argument with the id before passing them along.
	arguments[1] = $(arguments[1]); // get the jquery dom node
	var newinstr = construct(visir[name], arguments);

	var entry = { instrument: newinstr, id: id, domnode: arguments[1], instrInfo: this._instrumentInfo[name], name: name };
	this._instruments.push(entry);

	if (this._extServices && typeof newinstr.UseExteralService == "function") {
		newinstr.UseExteralService(this._extServices);
	}

	return newinstr;
}

visir.InstrumentRegistry.prototype._NextInstrID = function(name)
{
	//XXX: check the db for instr type and update the counts
	if (!this._instrumentInfo[name]) throw "Instrument name not found in InstrumentRegistry";
	return ++this._registeredTypes[this._instrumentInfo[name].type];
}

visir.InstrumentRegistry.prototype.WriteRequest = function()
{
	var out = "";
	for(var i=0;i<this._instruments.length; i++) {
		out += this._instruments[i].instrument.WriteRequest();
	}
	return out;
}

visir.InstrumentRegistry.prototype.ReadResponse = function(response)
{
	for(var i=0;i<this._instruments.length; i++) {
		this._instruments[i].instrument.ReadResponse(response);
	}
}

visir.InstrumentRegistry.prototype.ReadSave = function(response)
{
	var $response = $(response);
	$response.find('protocol').remove();

	for(var i=0;i<this._instruments.length; i++) {
		if (typeof (this._instruments[i].instrument.ReadSave) == "function") {
			this._instruments[i].instrument.ReadSave($response);
		}
	}

	if (visir.Config.Get("displayManuals") == false) {
		$(".manual_link").remove();
	}
}

visir.InstrumentRegistry.prototype.WriteSave = function(includeRequest)
{
	$xml = $('<save version="2" />');
	var instrumentlist = "";
	var instrumentlistvalues = "";
	var firstTime = true;

	for(var i = 0; i < this._instruments.length; i++) {
		if (i>0) {
			instrumentlist += "|";
		}
		instrumentlist += this._instruments[i].name;

		if (visir.Config.Get("unrFormat")) {
			if (this._instruments[i].name == "HPFunctionGenerator" || this._instruments[i].name == "TripleDC") {
				instrumentlistvalues += this._instruments[i].name + "#" + this._instruments[i].instrument._ReadCurrentValues().toString();
				if (firstTime) {
					instrumentlistvalues += "|";
					firstTime = false;
				}
			}
		}
	}
	var $instruments = $('<instruments />').attr("htmlinstruments", instrumentlist);
	$xml.append($instruments);

	if (visir.Config.Get("unrFormat")) {
		var $instruments_values = $('<instrumentsvalues />').attr("htmlinstrumentsvalues", instrumentlistvalues);
		$xml.append($instruments_values);
	}

	for(var i=0;i<this._instruments.length; i++) {
		if (typeof (this._instruments[i].instrument.WriteSave) == "function") {
			$xml.append(this._instruments[i].instrument.WriteSave());
		}
	}

	if (includeRequest === true) {
		var requestContents = this.WriteRequest();
		var $protocol = $("<protocol version=\"1.3\"><request></request></protocol>");
		$protocol.find("request").append($(requestContents));
		$xml.append($protocol);
	}


	return $("<root />").append($xml).html();
}

visir.InstrumentRegistry.prototype.MakeRequest = function(transport)
{
	var me = this;
	transport.Request(this.WriteRequest(), function(res) { me.ReadResponse(res); } );
}

// XXX: don't know if this is going to stay here or in some other class
//

visir.InstrumentRegistry.prototype._CreateInstrContainer = function(type)
{
	var id = this._registeredTypes[type]+1;
	return $('<div class="instrument" id="' + type + id + '" />');
}

visir.InstrumentRegistry.prototype._CreateInstrFromSWF = function(swf, $loc)
{
	for (var key in this._instrumentInfo) {
		if (this._instrumentInfo[key].swf == swf) {
			var $ctnr = this._CreateInstrContainer(this._instrumentInfo[key].type);
			var newinstr = this.CreateInstrument(key, $ctnr);
			$loc.append($ctnr);
			return newinstr;
		}
	}
	return null;
}

visir.InstrumentRegistry.prototype.LoadExperimentFromURL = function(url, $loc)
{
	var me = this;
	$.get(url, function(data) {
		me.LoadExperiment(data, $loc);
	});
}

visir.InstrumentRegistry.prototype.CreateInstrFromJSClass = function(classname, $loc)
{
	trace("creating instrument from js name: " + classname);
	var $ctnr = this._CreateInstrContainer(this._instrumentInfo[classname].type);
	this.CreateInstrument(classname, $ctnr);
	$loc.append($ctnr);
}

visir.InstrumentRegistry.prototype.LooksLikeSaveXML = function($xml)
{
	if ($xml.prop("tagName") != "SAVE") return false;
	var versionNr = parseInt($xml.attr("version"), 10);
	if (versionNr < 2) return false;
	return true;
}

visir.InstrumentRegistry.prototype.LoadExperiment = function(xmldata, $loc)
{
	var $xml = $(xmldata);
	if (!this.LooksLikeSaveXML($xml)) {
		alert("Failed to load experiment, invalid save data");
		return;
	}
	
	$loc.find(".instrument").remove();
	this._Reset();
	var $instr = $xml.find("instruments");

	var flashlocs = $instr.attr("list");
	var swfs = flashlocs ? flashlocs.split("|") : [];

	for(var i=0;i<swfs.length; i++) {
		trace("creating instrument from swf: " + swfs[i]);
		this._CreateInstrFromSWF(swfs[i], $loc);
	}

	var htmlinstr = $instr.attr("htmlinstruments");
	var htmlarr = htmlinstr ? htmlinstr.split("|") : [];
	for(var i=0; i<htmlarr.length; i++) {
		this.CreateInstrFromJSClass(htmlarr[i], $loc);
	}

	this.ReadSave($xml);
	this.Notify("onExperimentLoaded");
	$("body").trigger("configChanged");
}

visir.InstrumentRegistry.prototype.AddListener = function(listenTo)
{
	this._listeners.push(listenTo);
}

// XXX: do we need to fix arguments? lets see..
visir.InstrumentRegistry.prototype.Notify = function(func)
{
	for(var i=0;i<this._listeners.length; i++) {
		if (typeof this._listeners[i][func] == "function") this._listeners[i][func]();
	}
}

visir.InstrumentRegistry.prototype.RemoveInstrument = function(instrument)
{
	for(var i in this._instruments) {
		if (this._instruments[i] === instrument) {
			// XXX: what should we do with the registeredTypes? This is not really correct
			--this._registeredTypes[this._instrumentInfo[this._instruments[i].name].type];
			this._instruments[i].domnode.remove();
			this._instruments.splice(i, 1);
		}
	}
}

visir.InstrumentRegistry.prototype.GetNrInstrOfType = function(type)
{
	trace("reg: " + this._registeredTypes[type] + " " + type);
	return this._registeredTypes[type];
}

"use strict";

var visir = visir || {};

visir.Multimeter = function(id)
{
	this._id = id;
	this._mode = "off";
	this._resolution = "3.5";
	this._range = -1;
	this._autozero = 1;
	this._result = 0.0;
}

visir.Multimeter.prototype.SetMode = function(mode) { this._mode = mode; }
visir.Multimeter.prototype.GetMode = function() { return this._mode; }

visir.Multimeter.prototype.SetRange = function(range) { this._range = range; }
visir.Multimeter.prototype.GetRange = function() { return this._range; }

visir.Multimeter.prototype.SetResolution = function(res) { this._resolution = res; }
visir.Multimeter.prototype.GetResolution = function() { return this._resolution; }

visir.Multimeter.prototype.GetResult = function() { return this._result }
	
visir.Multimeter.prototype.WriteRequest = function()
{
	if (this._mode == "off") return ""; //'<multimeter id="'+ this._id + '" />';
	
	var $xml = $('<multimeter />');
	$xml.attr("id", this._id);
	
	var values = {
		dmm_function: this._mode
		, dmm_resolution: this._resolution
		, dmm_range: this._range
		, dmm_autozero: this._autozero
	};
	
	for (var key in values) {
		AddXMLValue($xml, key, values[key]);
	}
	
	// XXX: trick to get a valid root doc
	return $("<root />").append($xml).html();
},

visir.Multimeter.prototype.ReadResponse = function(response) {
	var $xml = $(response);
	var $multimeter = $xml.find("multimeter[id=" + this._id + "]");
	if ($multimeter.length > 0) {
		var result = $multimeter.find("dmm_result").attr("value");
		if (!isNaN(result))	{
			this._result = parseFloat(result);
		} else {
			this._result = NaN;
		}
	}	
}

"use strict";

var visir = visir || {};

visir.Oscilloscope = function(id)
{
	this._id = id;

	this._autoScale = 0;
	this._sampleRate = 500; // ?
	this._horzRefPos = 50;
	this._recordLength = 500; // number of samples to aquire

	function NewGraph(l)
	{
		var out = new Array(l);
		for(var i=0; i<l; i++) { out[i] = 0.0; }
		return out;
	}

	var channel1 = { enabled: 1, visible: true, coupling: "dc", range: 1, offset: 0, attenuation: 1.0, graph: NewGraph(500) };
	var channel2 = { enabled: 1, visible: true, coupling: "dc", range: 1, offset: 0, attenuation: 1.0, graph: NewGraph(500) };
	this._channels = [ channel1, channel2 ];

	this._trigger = {
		source: 1 //"channel 1"
		, slope: "positive"
		, coupling: "dc"
		, level: 0.0
		, mode: "autolevel"
		, timeout: 1.0
		, delay: 0.0
	}

	/*var m1 = { channel: 1, selection: "none", result: "" };
	var m2 = { channel: 1, selection: "none", result: "" };
	var m3 = { channel: 1, selection: "none", result: "" };*/
	this._measurements = [];
}

// XXX: the extra parameter is a horrible hack..
visir.Oscilloscope.prototype.AddMeasurement = function(ch, selection, extra)
{
	var rv = -1;
	for(var i=0;i<this._measurements.length; i++) {
		if (this._measurements[i].channel == ch && this._measurements[i].selection == selection) {
			this._measurements.splice(i, 1);
			rv = i;
			break;
		}
	}

	while(this._measurements.length > 2) this._measurements.shift();
	this._measurements.push( { channel: ch, selection: selection, extra: extra, result: "" } );
	return rv;
}

visir.Oscilloscope.prototype.WriteRequest = function()
{
	var $xml = $('<oscilloscope><horizontal></horizontal><channels></channels><trigger></trigger><measurements></measurements></oscilloscope>');
	$xml.attr("id", this._id);

	AddXMLValue($xml, "osc_autoscale", this._autoScale);

	// horizontal
	var $horz = $xml.find("horizontal");
	AddXMLValue($horz, "horz_samplerate", this._sampleRate);
	AddXMLValue($horz, "horz_refpos", this._horzRefPos);
	AddXMLValue($horz, "horz_recordlength", this._recordLength);

	// assume 2 channels
	for(var i=0; i<2; i++) {
		var ch = this._channels[i];
		var $channel = $('<channel/>');
		$channel.attr("number", i+1);
		AddXMLValue($channel, "chan_enabled", ch.enabled);
		AddXMLValue($channel, "chan_coupling", ch.coupling);
		AddXMLValue($channel, "chan_range", ch.range);
		AddXMLValue($channel, "chan_offset", ch.offset);
		AddXMLValue($channel, "chan_attenuation", ch.attenuation);
		$xml.find("channels").append($channel);
	}

	var $trigger = $xml.find("trigger");
	var trig = this._trigger;
	AddXMLValue($trigger, "trig_source", "channel " + trig.source);
	AddXMLValue($trigger, "trig_slope", trig.slope);
	AddXMLValue($trigger, "trig_coupling", trig.coupling);
	AddXMLValue($trigger, "trig_level", trig.level);
	AddXMLValue($trigger, "trig_mode", trig.mode);
	AddXMLValue($trigger, "trig_timeout", trig.timeout);
	AddXMLValue($trigger, "trig_delay", trig.delay);

	for(var i=0; i<3; i++) {
		var channel = 1;
		var selection = "none";
		if (i < this._measurements.length) {
			var meas = this._measurements[i];
			channel = meas.channel;
			selection = meas.selection;
		}

		var $measure = $('<measurement/>');
		$measure.attr("number", i+1);
		AddXMLValue($measure, "meas_channel", "channel " + channel);
		AddXMLValue($measure, "meas_selection", selection);
		$xml.find("measurements").append($measure);
	}

	return $("<root />").append($xml).html();
}

visir.Oscilloscope.prototype.ReadResponse = function(response) {
	var me = this;
	var $xml = $(response);
	var $oscilloscope = $xml.find("oscilloscope"); // add id match later, when server supports it
	if ($oscilloscope.length == 0) return;

	$oscilloscope.find("channel").each(function() {
		var $channel = $(this);
		var chnr = $channel.attr("number");
		var $samples = $channel.find("chan_samples");
		if ($samples.attr("encoding") != "base64") throw "unknown encoding";
		var gain = parseFloat($channel.find("chan_gain").attr("value"));
		var offset = parseFloat($channel.find("chan_offset").attr("value"));
		var base64text = $samples.text();
		var a = base64_decode(base64text);
		var graph = [];
		for(var i in a) {
			if (a[i] > 127) a[i] = a[i] - 256;
			graph[i] = a[i] * gain + offset;
		}
		me._channels[chnr - 1].graph = graph;
	});

	$oscilloscope.find("measurement").each(function() {
		var $measurement = $(this);
		var measnr = parseInt($measurement.attr("number"), 10);
		var channel = $measurement.find("meas_channel").attr("value");
		var selection = $measurement.find("meas_selection").attr("value");
		var result = parseFloat($measurement.find("meas_result").attr("value"));
		if (me._measurements.length >= measnr) me._measurements[measnr - 1].result = result;
	});
}

"use strict";

var visir = visir || {};

visir.FunctionGenerator = function(id)
{
	this._id = id;
	this._waveform = "sine";
	this._frequency = 1000.0;
	this._amplitude = 1.0;
	this._offset = 0.0;
}
	
visir.FunctionGenerator.prototype.WriteRequest = function()
{
	var $xml = $("<functiongenerator></functiongenerator>");
	$xml.attr("id", this._id);
	
	AddXMLValue($xml, "fg_waveform", this._waveform);
	AddXMLValue($xml, "fg_frequency", this._frequency);
	AddXMLValue($xml, "fg_amplitude", this._amplitude / 2.0);
	AddXMLValue($xml, "fg_offset", this._offset);
		
	// XXX: trick to get a valid root doc
	return $("<root />").append($xml).html();
},

visir.FunctionGenerator.prototype.ReadResponse = function(response) {
}

visir.FunctionGenerator.prototype.GetWaveform = function() { return this._waveform; }
visir.FunctionGenerator.prototype.SetWaveform = function(waveform) { this._waveform = waveform; }
"use strict";

var visir = visir || {};

visir.DCPower = function(id)
{
	this._id = id;
	this._channels = {
		"6V+": { voltage: 0.0, current: 0.5, measured_voltage: 0, measured_current: 0, limited: 0, enabled: 0 },
		"25V+": { voltage: 0.0, current: 0.5, measured_voltage: 0, measured_current: 0, limited: 0, enabled: 0 },
		"25V-": { voltage: 0.0, current: 0.5, measured_voltage: 0, measured_current: 0, limited: 0, enabled: 0 }
	 }
}

// XXX: Should probably fix a nicer interface for changing the settings
visir.DCPower.prototype.GetChannel = function(ch)
{
	return this._channels[ch];
}
	
visir.DCPower.prototype.WriteRequest = function()
{
	var $xml = $("<dcpower><dc_outputs/></dcpower>");
	$xml.attr("id", this._id);
	var $outputs = $xml.find("dc_outputs");
	for(var key in this._channels)
	{
		var ch = this._channels[key];
		var $channel = $("<dc_output/>");
		$channel.attr("channel", key);
		AddXMLValue($channel, "dc_voltage", ch.voltage);
		AddXMLValue($channel, "dc_current", ch.current);
		$outputs.append($channel);
	}	
	
	// XXX: trick to get a valid root doc
	return $("<root />").append($xml).html();
},

visir.DCPower.prototype.ReadResponse = function(response) {
	var me = this;
	var $xml = $(response);
	var $dcpower = $xml.find("dcpower"); // add id match later, when server supports it
	if ($dcpower.length == 0) return;
	//trace("xml: " + $dcpower.html());
	
	$dcpower.find("dc_output").each(function() {
		var $channel = $(this);
		var chname = $channel.attr("channel");
		var actual_voltage = parseFloat($channel.find("dc_voltage_actual").attr("value"));
		var actual_current = parseFloat($channel.find("dc_current_actual").attr("value"));
		var enabled = parseInt($channel.find("dc_output_enabled").attr("value"));
		var limited = parseInt($channel.find("dc_output_limited").attr("value"));
		if (me._channels[chname]) {
			me._channels[chname].measured_voltage = actual_voltage;
			me._channels[chname].measured_current = actual_current;
			me._channels[chname].limited = limited;
			me._channels[chname].enabled = enabled;
		}
	});
}

"use strict";

var visir = visir || {};

function snapPoint(p)
{
	p.x += 6; p.y += 6;
	p.x = p.x - (p.x % 13);
	p.y = p.y - (p.y % 13);
	p.x -= 5;
	p.y += 3;
}

function toBoardCoords(p)
{
	p.x = p.x / 13 | 0;
	p.y = p.y / 13 | 0;
}

//////////////////////////////////////////////////////////////////////////////
// Point

visir.Point = function(x,y)
{
	this.x = x || 0;
	this.y = y || 0;
}

visir.Point.prototype.SnapToGrid = function()
{
	this.x += 6; this.y += 6;
	this.x = this.x - (this.x % 13);
	this.y = this.y - (this.y % 13);
	this.x -= 5;
	this.y += 3;
}

visir.Point.prototype.Add = function(p)
{
	return new visir.Point(this.x + p.x, this.y + p.y);
}

visir.Point.prototype.toString = function()
{
	return "(x: " + this.x + " y: " + this.y + ")";
}

//////////////////////////////////////////////////////////////////////////////
// Wire

visir.Wire = function(color)
{
	this._color = color;
	this._lineWidth = 3.4;
	this._start = new visir.Point();
	this._end = new visir.Point();
	this._mid = new visir.Point();
}

visir.Wire.prototype.SetBentPoints = function(start, end)
{
	if (start.x > end.x) {
		var p1 = end;
		var p2 = start;
	}
	else {
		var p1 = start;
		var p2 = end;
	}

	var diff = { x: p2.x - p1.x, y: p2.y - p1.y };
	var cross = { x: diff.y, y: -diff.x };
	var scale = 5;
	cross.x /= scale;
	cross.y /= scale;

	var mid = new visir.Point();
	mid.x = start.x + (end.x - start.x) / 2;
	mid.y = start.y + (end.y - start.y) / 2;
	mid.x += cross.x;
	mid.y += cross.y;

	this.SetPoints(start, mid, end);
}

visir.Wire.prototype.SetPoints = function(start, mid, end)
{
	this._start = start;
	this._mid = mid;
	this._end = end;
}

visir.Wire.prototype.Draw = function(context)
{
	this._RawDraw(context, this._color, this._lineWidth);
}

visir.Wire.prototype.DrawShadow = function(context, color, width)
{
	var diff = { x: this._end.x - this._start.x, y: this._end.y - this._start.y };
	var len = Math.sqrt(diff.x * diff.x + diff.y * diff.y);

	var scale = 20.0;
	var midx = this._mid.x + len / scale;
	var midy = this._mid.y + len / scale;

	context.save();

	context.shadowBlur=7;
	context.shadowColor="black";
	context.lineCap = 'round';
	context.strokeStyle = 'rgba(0,0,0,0.2)';
	context.lineWidth   = width-1;
	context.beginPath();
	context.moveTo(this._start.x, this._start.y);
	 // +1 is for avoiding having same start and end, which leads to no painting at all
	context.quadraticCurveTo(midx, midy, this._end.x+1, this._end.y);
	context.stroke();
	context.closePath();

	context.restore();
}


visir.Wire.prototype._RawDraw = function(context, color, width)
{
	context.lineCap = 'round';
	context.strokeStyle = color;
	context.lineWidth   = width;
	context.beginPath();
	context.moveTo(this._start.x, this._start.y);
	 // +1 is for avoiding having same start and end, which leads to no painting at all
	context.quadraticCurveTo(this._mid.x, this._mid.y, this._end.x+1, this._end.y);
	context.stroke();
	context.closePath();
}

//////////////////////////////////////////////////////////////////////////////
// Grid

// Ocuppation grid for the bin (to know which positions are available)
visir.Grid = function(componentList, $bin) {
	var me = this;

	// Being true = "available", and false = "busy"
	this._grid = [
	// row 0 (y=0): [ true, true, true ... ],
	// row 1 (y=1): [ true, true, true ... ],
	];

	this._rows = 7;
	this._cols = 54;

	for(var y = 0; y < this._rows; y++) {
		var rowOccupation = [];
		for(var x = 0; x < this._cols; x++)
		rowOccupation.push(true);
		this._grid.push(rowOccupation);
	}

	var bin_position = $bin.position();
	var bin_left = bin_position.left;
	var bin_top  = bin_position.top;

	$(componentList).each(function(pos, component) {
		var position = component._$elem.position();
		var relative_left = Math.floor((position.left - bin_left - 5 + parseInt(component.translation.x)) / 13);
		var relative_top  = Math.floor((position.top  - bin_top  - 5 + parseInt(component.translation.y)) / 13);

		/*
		trace("Marking: " + component._type + " " + component._value);
		trace("rel: " + relative_left + " " + relative_top);
		trace("size: " + component.widthInPoints() + " " + component.heightInPoints());
		*/

		var margin = 5;
		var wip = Math.ceil((component.width()+margin) / 13);
		var hip = Math.ceil((component.height()+margin) / 13);

		// trace("Component found in: " + relative_top + ", " + relative_left);

		//if(relative_top >= 0 && relative_top < me._rows && relative_left >= 0 && relative_left < me._cols) {
			for(var x = relative_left; x < relative_left + wip; x++)
			for(var y = relative_top; y < relative_top + hip; y++) {
				if (x >= 0 && x<me._cols && y >= 0 && y<me._rows) {
					me._set(x,y, false);
				}
				//trace("Marking busy..." + x + "; " + y + " " + component._type + " " + component._value);
			}
		//}
	});
}

visir.Grid.prototype._get = function(x, y)
{
	//trace("Attempting " + x + ", " + y + " " + this._grid[y][x]);
	return this._grid[y][x];
}

visir.Grid.prototype._set = function(x, y, value)
{
	//trace("Attempting " + x + ", " + y + " " + value);
	this._grid[y][x] = value;
}


visir.Grid.prototype._FindSlot = function(height, width)
{
	for (var x = 0; x <= this._cols - width; x++) { // x = 0 .. ~54
		for (var y = 0; y <= this._rows - height; y++) { // y = 0 .. ~7
			if (this._get(x, y)) {
				var potentialHole = true;
				for (var x2 = x; x2 < this._cols && x2 < x + width && potentialHole; x2++) {
					for (var y2 = y; y2 < this._rows && y2 < y + height && potentialHole; y2++) {
						//trace("xx: " + x2 + " " + y2);
						// trace(this._grid);
						if (!this._get(x2, y2))
						potentialHole = false;
					}
				}
				if (potentialHole)
				return { 'x' : x, 'y' : y };
			}
		}
	}

	return { 'x' : 0, 'y' : 0 };
}


//////////////////////////////////////////////////////////////////////////////
// Component

// Component container
visir.Component = function($elem, breadboard, type, value)
{
	this._$elem        = $elem;
	this._breadboard   = breadboard;
	this._$circle      = null;
	this._current_step = 0; // current rotation
	this.translation   = { 'x' : 0, 'y' : 0 };
	this.translations  = [];
	this._pins = []; // one entry per rotation, each entry contains an array of points with offsets to where each pin is located
	this._type = type;
	this._value = value;
}

visir.Component.prototype.Move = function(x, y)
{
	this._$elem.css("left", x).css("top", y);
}

visir.Component.prototype.GetPos = function()
{
	return new visir.Point(parseInt(this._$elem.css("left"), 10), parseInt(this._$elem.css("top"), 10));
}

visir.Component.prototype.GetRotation = function()
{
	return this._current_step;
}

visir.Component.prototype.width = function()
{
	return this._$elem.find('.active').width();
}

visir.Component.prototype.height = function()
{
	return this._$elem.find('.active').height();
}

visir.Component.prototype.heightInPoints = function()
{
	return Math.ceil(this.height() / 13);
}

visir.Component.prototype.widthInPoints = function()
{
	return Math.ceil(this.width() / 13);
}

visir.Component.prototype.remove = function()
{
	this._$elem.remove();
	this._breadboard._RemoveComponent(this);
	this._breadboard.SelectComponent(null);
}

visir.Component.prototype._RemoveCircle = function()
{
	if(this._$circle != null) {
		this._$circle.remove();
		this._$circle = null;
	}
}

visir.Component.prototype._PlaceInBin = function()
{
	var grid = this._breadboard._BuildOccupationGrid();

	var height = this.heightInPoints();
	var width  = this.widthInPoints();

	var availablePos = grid._FindSlot(height, width);
	var bin_position = this._breadboard._GetBin().position();

	// TODO: Take into account: this.translation.rot
	this.Rotate(0);
	var new_left = availablePos.x * 13 + bin_position.left + 5 - parseInt(this.translation.x);
	var new_top  = availablePos.y * 13 + bin_position.top  + 5 - parseInt(this.translation.y);
	var p = new visir.Point(new_left, new_top);
	p.SnapToGrid();


	// trace("Available position found: [x=" + availablePos.x + ", y=" + availablePos.y + "] (which is [" + new_left + ", " + new_top + "])");

	this._$elem.css({
		"left" : p.x,
		"top"  : p.y,
	});
}

visir.Component.prototype.Rotate = function(step)
{
	if(step == undefined) {
		step = this._current_step + 1;
	}

	var $imgs = this._$elem.find("img");
	if (step >= $imgs.length) step = step % $imgs.length;
	// trace("step: " + step);
	var idx = 0;
	var currentImage = null;
	$imgs.each(function() {
		if (idx == step) {
			$(this).addClass("active");
			currentImage = $(this);
		} else {
			$(this).removeClass("active");
		}
		idx++;
	});
	this._current_step = step;
	this.translation   = this.translations[step];
	// trace("New translation: " + this.translation.x + "; " + this.translation.y);
}

visir.Component.prototype._AddCircle = function()
{
	var me = this;

	// Placed here for math operations
	// var CIRCLE_SIZE    =  140;
	var CIRCLE_SIZE    =  this.width() + 100;
	var ICON_SIZE      =  40;

	// If the circle may be slightly bigger than the four
	// corner icons, since circles don't have corners. This
	// constant establishes the level of overlap between the
	// square that surrounds a circle and the square that
	// surrounds the icons. Example: establishing it to 0
	// the circle will not overlap at all; establishing it to
	// 1 will overlap completely.
	var CIRCLE_OVERLAP =  0.4;

	// Where is the component?
	var originalTop  = parseInt(this._$elem.css('top'),  10);
	var originalLeft = parseInt(this._$elem.css('left'), 10);

	// Where should be located inside the circle?
	var relativeTop  = this._$elem.height() / 2;
	var relativeLeft = this._$elem.width()  / 2;

	// Where should the whole circle be located?
	var newTop       = originalTop  - relativeTop;
	var newLeft      = originalLeft - relativeLeft;

	// Overall block
	this._$circle = $('<span class="componentcircle"></span>');
	this._$circle.width(CIRCLE_SIZE);
		this._$circle.height(CIRCLE_SIZE);
	var transform = 'translate(-' + (CIRCLE_SIZE / 2) + 'px,-' + (CIRCLE_SIZE / 2) + 'px)';
	this._$circle.css({
		'position'  : 'absolute',
		'top'       : newTop + 'px',
		'left'      : newLeft + 'px',
		'transform' : transform,
		'-moz-transform' : transform,
		'-webkit-transform' : transform
	});

	// Circle
	//var $circleImg = $('<img src="instruments/breadboard/images/empty_circle.png"/>');
		var $circleImg = $('<div class="circle" />');
	$circleImg.width(CIRCLE_SIZE - 2 * (1 - CIRCLE_OVERLAP) * ICON_SIZE);
	$circleImg.height(CIRCLE_SIZE - 2 * (1 - CIRCLE_OVERLAP) * ICON_SIZE);
	$circleImg.css({
		'position' : 'absolute',
		'left'     : (1 - CIRCLE_OVERLAP) * ICON_SIZE,
		'top'      : (1 - CIRCLE_OVERLAP) * ICON_SIZE
	});
	this._$circle.append($circleImg);

	// Rotation button
	// Public domain
	// http://openclipart.org/detail/33685/tango-view-refresh-by-warszawianka
	var $rotateImg = $('<img src="' + me._breadboard._BuildImageUrl('rotate.png') + '"/>');
	$rotateImg.width(ICON_SIZE);
	$rotateImg.height(ICON_SIZE);
	$rotateImg.css({
		'position' : 'absolute',
		'left'     : CIRCLE_SIZE - ICON_SIZE,
		'top'      : CIRCLE_SIZE - ICON_SIZE
	});
	$rotateImg.click(function() {
		me.Rotate();
	});
	this._$circle.append($rotateImg);

	// Drag and drop button
	this._breadboard._$elem.find("#comp_circle").append(this._$circle);

//	if ($.browser.msie)
//	{
//		if (parseInt($.browser.version, 10) >= 9) {
//			this._breadboard._$elem.find("#comp_circle").find("*").css("z-index", "15");
//		}
//	}


	var handler = this.generateHandler(this._$circle, function() {
		// On clicked
		me._breadboard.SelectComponent(null);
	}, this._$elem, function() {
	}, function () {
	});

	$circleImg.on("mousedown touchstart", handler);
}

visir.Component.prototype.GenCircuitIfUsed = function()
{
	var out = this._type + "_X";

	var rot = this._current_step;
	var pins = this._pins[rot];
	if (pins.length == 0) return null; // assert?

	for(var i = 0; i< pins.length; i++) {
		var p = this._breadboard._GetNodeName(this._GetPinPoint(pins[i]));
		if (!p) return null;
		out += " " + p;
	}
	return out + " " + this._value + "\n";
}

visir.Component.prototype._GetPinPoint = function(p)
{
	var mx = parseInt(this._$elem.css('left'));
	var my = parseInt(this._$elem.css('top'));
	//trace("mx/y: " + mx + " " + my + "-" + p);
	return new visir.Point(mx + p.x, my + p.y);
}

//////////////////////////////////////////////////////////////////////////////
// Breadboard

var debugbb;

visir.Breadboard = function(id, $elem)
{
	var me = this;
	debugbb = this;
	this._$elem = $elem;
	this._$library = null;
	this._onLibraryLoaded = null;
	this._components = [];
	this._wires = [];
	this._instruments = [];
	this._selectedWire = null; // index in _wires
	this._selectedCompnent = null;

	this._isTouchDevice = navigator.userAgent.match(/iPhone|iPad|Android/)
	if (this._isTouchDevice) this._fingerOffset = new visir.Point(0, -26);
	else this._fingerOffset = new visir.Point(0, 0);

	this.IMAGE_URL = "instruments/breadboard/images/";
	if (visir.BaseLocation) this.IMAGE_URL = visir.BaseLocation + this.IMAGE_URL;

	var tpl = '<div class="breadboard">\
	<img class="background" src="' + this._BuildImageUrl('breadboard.png') + '" alt="breadboard"/>\
	<div class="clickarea"></div>\
	<div class="bin">\
		<div class="reset">'+visir.Lang.GetMessage('reset')+'</div>\
   	<div class="teacher">+</div>\
	</div>\
	<div class="colorpicker">\
		<p class="title">'+visir.Lang.GetMessage('wire_sel')+'</p>\
		<div class="border">\
			<div class="color red"></div>\
			<div class="color black"></div>\
			<div class="color green"></div>\
			<div class="color yellow"></div>\
			<div class="color blue"></div>\
			<div class="color brown"></div>\
			<div class="currentcolor"></div>\
		</div>\
	</div>\
	<div class="indicator"></div>\
	<div class="delete"></div>\
	<div class="help">?</div>\
	<div class="components"></div>\
	<div class="instruments">\
		<div class="left"></div>\
	</div>\
	<canvas id="wires" width="715" height="450"></canvas>\
	<div id="wire_start" class="wirepoint start"></div>\
	<div id="wire_mid" class="wirepoint mid"></div>\
	<div id="wire_end" class="wirepoint end"></div>\
	<div id="comp_circle" class="comp_circle"></div>\
	<div class="componentbox">\
	    <div class="componentlist">\
	        <table class="componentlist-table">\
	        </table>\
	    </div>\
	    <div class="componentbutton">\
	        <button>'+visir.Lang.GetMessage('close')+'</button>\
	    </div>\
	</div>\
	</div>';

	//tpl += '<div id="debug"></div>'

	$elem.append(tpl);

	var $wires = $elem.find("#wires");
	if (typeof G_vmlCanvasManager !== "undefined")
	{
		G_vmlCanvasManager.initElement($wires);
	}
	var $doc = $(document);
	var context = $wires[0].getContext('2d');
	this._wireCtx = context;
	this._$wires = $wires;
	var $click = $elem.find(".clickarea");

	$wires.click( function() { trace("Clicked wires"); });

	// create offsceen canvas for wire picking
	var offscreen_canvas = document.createElement('canvas');
	if (typeof G_vmlCanvasManager !== "undefined")
	{
		G_vmlCanvasManager.initElement(offscreen_canvas);
	}
	offscreen_canvas.width = 715; //$wires.parent().width();
	offscreen_canvas.height = 450; //$wires.parent().height();
	this._offWireCtx = offscreen_canvas.getContext('2d');
	//$elem.find("#debug").append(offscreen_canvas);
	//document.getElementById("debug").appendChild(offscreen_canvas);

 // TODO: make it configurable (argument?)
	var teacher_mode = (visir.Config) ? visir.Config.Get("teacher") : true;
	if(!teacher_mode) $elem.find(".teacher").hide();

	$elem.find(".teacher").click(function(e) {
		if (!visir.Config.Get("readOnly"))
		{
			$elem.find(".componentbox").show();
			$elem.find(".componentlist-table").empty();
			var $components = me._$library.find("component").each(function() {
				var img   = $(this).find("rotation").attr("image");
				var type  = $(this).attr("type");
				var value = $(this).attr("value");
				var img_html = '<tr class="component-list-row">\
				<td>\
				<img src="' + me._BuildImageUrl(img) + '"/>\
				</td>\
				<td>' + type + '</td>\
				<td>' + value + '</td>\
				</tr>';
				$elem.find(".componentlist-table").append(img_html);

				$($elem.find('.component-list-row').get(-1)).click(function(e){
					var comp_obj = me.CreateComponent(type, value);
					comp_obj._PlaceInBin();
				});
			});
		}
	});

		$elem.find(".reset").click( function(e) {
			if (!visir.Config.Get("readOnly"))
			{
				// Send all the components back to the bin
				for(var i=0;i<me._components.length;i++) {
					me._components[i].Move(500,500); // move away from the bin
				}
				for(var i=0;i<me._components.length;i++) {
					me._components[i]._PlaceInBin();
				}

				me.SelectWire(null);
				me.SelectComponent(null);
				me._wires = [];
				me._DrawWires();
			}
		});

	$elem.find(".componentbutton button").click(function(e) {
		$elem.find(".componentbox").hide();
	});

	$click.on("mousedown touchstart", function(e) {
		if (!visir.Config.Get("readOnly"))
		{
			trace("touch");
			var wires_offset = $wires.offset();
			var offset = { x: wires_offset.left, y: wires_offset.top };

			if (!me._color) {
				// do picking against the wires

				// don't care if we got more than one touch
				// we can probably do something smarter here, to avoid problems when scrolling etc.
				if (e.originalEvent.touches && e.originalEvent.touches.length > 1) return;

				var touch = (e.originalEvent.touches) ? e.originalEvent.touches[0] : e;
				var start = new visir.Point(touch.pageX - offset.x, touch.pageY - offset.y);
				var idx = me._PickWire(start.x, start.y);
				if (idx !== null) {
					e.preventDefault();
					me.SelectWire(idx);
					me.SelectComponent(null);
					return;
				}

				// nothing was picked
				me.SelectWire(null);
				me.SelectComponent(null);

				return;
			}
			//trace("mouse down");
			e.preventDefault();

			// Draw new wire
			var nWire = new visir.Wire(me._color); // XXX: replace with CreateWire
			me._wires.push(nWire);

			e = (e.originalEvent.touches) ? e.originalEvent.touches[0] : e;

			var start = new visir.Point(e.pageX - offset.x, e.pageY - offset.y);
			start = start.Add(me._fingerOffset);
			start.SnapToGrid();

			$click.on("mousemove.rem touchmove.rem", function(e) {
				e = (e.originalEvent.touches) ? e.originalEvent.touches[0] : e;
				var end = new visir.Point(e.pageX - offset.x, e.pageY - offset.y);
				end = end.Add(me._fingerOffset);
				end.SnapToGrid();

				nWire.SetBentPoints(start, end);
				me._DrawWires();

				//trace("move")
			});

			$doc.on("mouseup.rem touchend.rem", function(e) {
				trace("mouseup");
				$click.off(".rem");
				$doc.off(".rem");

				// deselect the color picker
				me._color = null;
				me._$elem.find(".color").removeClass("selected");
			});
		}
	});

	$elem.find(".color").click( function() {
		if (!visir.Config.Get("readOnly"))
		{
			me.SelectWire(null);
			me.SelectComponent(null);

			me._color = $(this).css("background-color");
			me._$elem.find(".color").removeClass("selected");
			$(this).addClass("selected");
		}
	});

	$elem.find(".delete").click( function() {
		if (!visir.Config.Get("readOnly"))
		{
			if (me._selectedWire !== null) {
				me._RemoveWire(me._wires[me._selectedWire]);
				me.SelectWire(null);
			}
			if (me._selectedCompnent) {
				me._selectedCompnent._PlaceInBin();
				me.SelectComponent(null);
			}
		}
	});

	$elem.find(".help").click( function() {
		me.ShowHelp(true);
	});

	function GenWirePointMove(snap, assign)
	{
		return function($elem, x, y) {
			if (me._selectedWire === null) return;
				var p = new visir.Point(x, y);

				// add a finger offset if on a mobile touch screen device
				p = p.Add(me._fingerOffset);
				if (snap) p.SnapToGrid();
				assign(p);
				me._DrawWires();

				var retp = new visir.Point(p.x - $elem.width() / 2, p.y - $elem.height() / 2);
				return retp;
		}
	}

	$elem.find("#wire_start").draggable( {
		move: GenWirePointMove(true, function(p) { me._wires[me._selectedWire]._start = new visir.Point(p.x, p.y); } )
	});

	$elem.find("#wire_mid").draggable( {
		move: GenWirePointMove(false, function(p) { me._wires[me._selectedWire]._mid = new visir.Point(p.x, p.y); } )
	});

	$elem.find("#wire_end").draggable( {
		move: GenWirePointMove(true, function(p) { me._wires[me._selectedWire]._end = new visir.Point(p.x, p.y); } )
	});

	var libraryxml = "instruments/breadboard/library.xml";
	if (visir.BaseLocation) libraryxml = visir.BaseLocation + libraryxml;
	if (visir.Config.Get("libraryXml")) libraryxml = visir.Config.Get("libraryXml");
	me._ReadLibrary(libraryxml);
	me._AddInstrumentConnections();

	$("body").on("configChanged", function(e) {
		me._AddInstrumentConnections();
	});
}

visir.Breadboard.prototype.Clear = function()
{
	while(this._components.length > 0) this._components[0].remove();
	this._wires = [];
	this._DrawWires();
}

visir.Breadboard.prototype._PickWire = function(x, y)
{
	var pickWidth = 20;
	this._offWireCtx.clearRect(0,0, this._$wires.width(), this._$wires.height());
	for(var i=0;i<this._wires.length; i++)
	{
		this._wires[i]._RawDraw(this._offWireCtx, 'rgba(' + (i+1) + ', 0, 0, 1)', pickWidth);
	}
	var c = this._offWireCtx.getImageData(x, y, 1, 1).data;
	trace("c: " + c[0] + " " + c[1] + " " + c[2] + " " + c[3]);
	var r = c[0] - 1;

	/*for(var i=0;i<this._wires.length; i++)
	{
		this._wires[i].Draw(this._offWireCtx);
	}

	this._offWireCtx.strokeStyle = "#ff0000";
	this._offWireCtx.lineWidth = 1;
	this._offWireCtx.beginPath();
	this._offWireCtx.arc(x, y, 2, 0, Math.PI*2, true);
	this._offWireCtx.closePath();
	this._offWireCtx.stroke();
	*/

	return (r >= 0) ? r : null;
}

visir.Breadboard.prototype._DrawWires = function()
{
	this._wireCtx.clearRect(0,0, this._$wires.width(), this._$wires.height());

	for(var i=0;i<this._wires.length; i++)
	{
		this._wires[i].DrawShadow(this._wireCtx, "#000", 5);
	}

	for(var i=0;i<this._wires.length; i++)
	{
		if (this._selectedWire === i) continue;
		this._wires[i].Draw(this._wireCtx);
	}

	// draw outline if selected
	// always draw the selected wired on top
	this._wireCtx.save();
	if (this._selectedWire !== null) {
		this._wires[this._selectedWire]._RawDraw(this._wireCtx, "#000", 5);
		this._wires[this._selectedWire].Draw(this._wireCtx);
	}
	this._wireCtx.restore();
}

visir.Breadboard.prototype.SelectWire = function(idx)
{
	trace("selected wire: " + idx);
	this._selectedWire = idx;
	this._DrawWires();

	this._UpdateTrashIcon();

	if (idx === null) {
		this._$elem.find(".wirepoint").removeClass("enabled");
		//this._$elem.find(".delete").removeClass("enabled");
		return;
	}

	this._$elem.find(".wirepoint").addClass("enabled");
	//this._$elem.find(".delete").addClass("enabled");

	function UpdatePoint($e, p) {
			var x = p.x - $e.width() / 2;
			var y = p.y - $e.height() / 2;
			x = x | 0;
			y = y | 0;
			$e.css("left", x).css("top", y);
	}

	var w = this._wires[idx];
	UpdatePoint(this._$elem.find("#wire_start"), w._start);
	UpdatePoint(this._$elem.find("#wire_mid"), w._mid);
	UpdatePoint(this._$elem.find("#wire_end"), w._end);
}

visir.Breadboard.prototype.ShowComponentIndicator = function(comp)
{
	var value = "";
	if (comp) {
		value = comp._type + " " + comp._value;
	}
	this._$elem.find(".indicator").text(value);
}

visir.Breadboard.prototype.SelectComponent = function(comp)
{
	var prev = this._selectedCompnent;
	this._selectedCompnent = comp;
	this._UpdateTrashIcon();
	if (prev) prev._RemoveCircle();
	if (comp) {
		comp._AddCircle();
		this._$elem.find(".indicator").text(comp._type + " " + comp._value);
		// deselect wire color
		// XXX: Refactor into function?
		this._color = null;
		this._$elem.find(".color").removeClass("selected");
	} else {
		this._$elem.find(".indicator").text("");
	}
}

visir.Breadboard.prototype._UpdateTrashIcon = function()
{
	if (this._selectedCompnent || this._selectedWire !== null) {
		this._$elem.find(".delete").addClass("enabled");
	} else {
		this._$elem.find(".delete").removeClass("enabled");
	}
}

visir.Breadboard.prototype._UpdateDisplay = function(ch)
{
}

visir.Breadboard.prototype._ReadLibrary = function(url)
{
	var me = this;
	$.ajax({
		type: "GET",
		url: url,
		dataType: "xml",
		async: true,
		success: function(xml) {
			me._$library = $(xml);
			if (me._onLibraryLoaded) me._onLibraryLoaded();
		}
	}).fail(function() { alert("failed to read component library"); })
	;
}

visir.Breadboard.prototype.CreateComponent = function(type, value)
{
	//var BASE_URL = "instruments/breadboard/images/";
	//if (visir.BaseLocation) BASE_URL = visir.BaseLocation + BASE_URL;

	var me = this;
	var $libcomp = this._$library.find('component[type="'+ type+'"][value="'+ value+ '"]');
	var $comp = $('<div class="component"></div>');
	var comp_obj = new visir.Component($comp, me, type, value);

	var idx = 0;

	$libcomp.find("rotation").each(function() {
		var imgtpl = '<img src="' + me._BuildImageUrl($(this).attr("image")) + '" alt="'+ type + value + '"/>';
		var $img = $(imgtpl);
		var rot = $(this).attr("rot");
		var ox = $(this).attr("ox");
		var oy = $(this).attr("oy");

		// fix weird library format..
		if (rot == 90 || rot == 270) {
			var tmp = ox;
			ox = oy;
			oy = tmp;
		}

		var transform = "";
		transform	+= ' translate(' + ox + 'px, ' + oy + 'px)';
		transform += ' rotate(' + rot + 'deg)';

		$img.css( {
			'transform': transform,
			'-moz-transform': transform,
			'-webkit-transform': transform,
//			, 'top': oy + 'px'
//			, 'left': ox + 'px'
		})

		var current_translation = { 'x' : ox, 'y' : oy, 'rot' : rot };
		comp_obj.translations.push(current_translation);
		//trace("Adding " + ox + ", " + oy);
		if (idx == 0) {
			$img.addClass("active");
			comp_obj.translation = current_translation;
		}
		$comp.append($img);

		$(this).find("pin").each( function() {
			var x = parseInt($(this).attr("x"));
			var y = parseInt($(this).attr("y"));
			if (!comp_obj._pins[idx]) comp_obj._pins[idx] = [];
			comp_obj._pins[idx].push(new visir.Point(x,y));
		});

		idx++;
	});

	me._components.push(comp_obj);
	me._AddComponentEvents(comp_obj, $comp);
	me._$elem.find(".components").append($comp);
	return comp_obj;
}

visir.Breadboard.prototype._AddComponentEvents = function(comp_obj, $comp)
{
	var me = this;
	var $doc = $(document);

	var offset = this._$elem.offset();

	var touches = 0;
	var initialTouchTime = 0;

	var generateHandler = function(component, callbackClicked, internalComponent, callbackPressed, callbackReleased) {
		return function(e) {
			e.preventDefault();

			initialTouchTime = new Date().getTime();

			touches = (e.originalEvent.touches) ? e.originalEvent.touches.length : 1;
			e = (e.originalEvent.touches) ? e.originalEvent.touches[0] : e;
			//var start = { x: e.pageX - offset.x, y: e.pageY - offset.y};

			$doc.on("keypress.rem", function(e) {
				if (!visir.Config.Get("readOnly"))
				{
					// trace("key: " + e.which);
					if (e.which == 114) // 'r'
					comp_obj.Rotate();
				}
			});

			$doc.on("keyup.rem", function(e){
				if (!visir.Config.Get("readOnly"))
				{
					if(e.keyCode == 46)
					comp_obj.remove();
				}
			})

			$doc.on("mousemove.rem touchmove.rem", function(e) {
				if (!visir.Config.Get("readOnly"))
				{
					if(callbackPressed != undefined)
					callbackPressed();

					touches = (e.originalEvent.touches) ? e.originalEvent.touches.length : 1;
					var touch = (e.originalEvent.touches) ? e.originalEvent.touches[0] : e;

					/*var p = new visir.Point(touch.pageX - offset.left, touch.pageY - offset.top);
					p.SnapToGrid();
					comp_obj.Move(p.x, p.y);*/

					var p = { x: touch.pageX - offset.left, y: touch.pageY - offset.top };
					snapPoint(p);
					//trace("move");
					component.css({
						"left": p.x + "px",
						"top": p.y + "px"
					});
					if(internalComponent != undefined) {
						internalComponent.css({
							"left": p.x + "px",
							"top": p.y + "px"
						});
					}

					// if two fingers are down, turn the component around towards the second finger
					if (e.originalEvent.touches && e.originalEvent.touches.length > 1) {
						var turn = e.originalEvent.touches[1];
						var angle = Math.atan2( touch.pageY - turn.pageY, touch.pageX - turn.pageX ) * 180 / Math.PI;
						angle = (angle + 360) % 360;
						var step = 0;
						if (angle < 45 || angle > 315) step = 0;
						else if (angle > 45 && angle < 135) step = 1;
						else if (angle >135 && angle < 225) step = 2;
						else step = 3;

						comp_obj.Rotate(step);
					}
				}
			});

			$doc.on("mouseup.rem touchend.rem", function(e) {
				trace("up: " + touches);
				if (touches > 1) {
					touches--;
					return;
				}

				var timeSincePressed = new Date().getTime() - initialTouchTime;
				trace("Time since pressed: " + timeSincePressed);
				if(timeSincePressed < 300) // Less than this time is considered a click
					callbackClicked();

				if(callbackReleased != undefined)
					callbackReleased();

				//if (e.originalEvent.touches && e.originalEvent.touches.length > 1) return;
				component.off(".rem");
				$doc.off(".rem");
			});
		};
	};

	$comp.on("mousedown touchstart", generateHandler($comp, function() {
		if (!visir.Config.Get("readOnly"))
		{
			// On clicked, add circle
			me.SelectComponent(comp_obj);
			me.SelectWire(null);
		}
	}));

	$comp.hover(
		function() {
			// in
			if (!me._selectedCompnent) me.ShowComponentIndicator(comp_obj);
		},
		function() {
			if (!me._selectedCompnent) me.ShowComponentIndicator(null);
		}
	);

	// XXX: this is hackish, we should do something better..
	comp_obj.generateHandler = generateHandler;
}

visir.Breadboard.prototype._RemoveWire = function(wire)
{
	for (var i = 0; i < this._wires.length; i++) {
		if(this._wires[i] == wire) {
			this._wires.splice(i, 1);
			return;
		}
	}
}

visir.Breadboard.prototype._RemoveComponent = function(comp_obj)
{
	for (var i = 0; i < this._components.length; i++) {
		if(this._components[i] == comp_obj) {
			this._components.splice(i, 1);
			return;
		}
	}
}

visir.Breadboard.prototype._BuildOccupationGrid = function()
{
	return new visir.Grid(this._components, this._GetBin());
}

visir.Breadboard.prototype._GetBin = function()
{
	return this._$elem.find(".bin");
}

visir.Breadboard.prototype._DrawHelpOverlay = function(ctx)
{
	var color = 'rgba(0,0,0,0.7)';
	var radius = 3;

	ctx.save();
	ctx.lineCap = 'round';
	ctx.strokeStyle = color;
	ctx.fillStyle = color;
	ctx.lineWidth   = 2;

	var bx = 152;
	var by = 146;

	function drawHorz(x, y) {
		ctx.beginPath();
		ctx.moveTo(x, y);
		ctx.lineTo(x + 13*28,y);
		ctx.stroke();
		ctx.closePath();

		for(var i=0;i<29;i++) {
			if (i % 6 == 5) continue;
			ctx.beginPath();
			ctx.arc(x+i*13, y, radius, 0, 2 * Math.PI, false);
			ctx.fill();
			ctx.closePath();
		}
	}

	function drawVert(x,y) {
		ctx.beginPath();
		ctx.moveTo(x, y);
		ctx.lineTo(x, y+ 13*4);
		ctx.stroke();
		ctx.closePath();
		for(var i=0;i<5; i++) {
			ctx.beginPath();
			ctx.arc(x, y + 13*i, radius, 0, 2 * Math.PI, false);
			ctx.fill();
			ctx.closePath();
		}
	}

	drawHorz(bx+13*2, by);
	drawHorz(bx+13*2, by+13);
	drawHorz(bx+13*2, by+13*20);
	drawHorz(bx+13*2, by+13*21);

	for(var i=0;i<32;i++) {
		// draw vertical bars
		var x = bx + i*13;
		var y = by + 13*5;
		drawVert(x, y);
		drawVert(x, y + 13*7);
	}

	ctx.restore();
}

visir.Breadboard.prototype.ShowHelp = function(show)
{
	this._showHelp = show;
	if (show) {
		this._DrawHelpOverlay(this._wireCtx);
	}
}

visir.Breadboard.prototype.CreateInstr = function(instr_type, instr_name)
{
	var me = this;

	var newinstr = {
		_type: instr_type,
		_name: instr_name,
		_connections: [],
		AddConnection: function(board_point, fixed_output) {
			//var p = new visir.Point(point.x / 13 | 0, point.y / 13 | 0);
			//trace("adding to instr: " + board_point + " " + instr_type);
			this._connections.push( { _point: board_point, fixed: fixed_output, marked: false });
			return this;
		},
		GetNameAndMarkIfUsed: function(point) {
			//trace("instr: " + this._type + " " + this._name + " " + point);
			for(var i=0;i<this._connections.length; i++) {
				//trace("checking against: " + this._connections[i]._point);
				if (point.x == this._connections[i]._point.x && point.y == this._connections[i]._point.y) {
					this._connections[i].marked = true;
					return this._ConnectionName(i);
				}
			}
		},
		GenInstrIfUsed: function() {
			if (this._type == "0") return; // special case for 0/GND instruments

			// if any of the points are marked, generate the instrument string
			var isUsed = false;
			var conStr = "";
			for(var i=0;i<this._connections.length; i++) {
				conStr += " " + this._ConnectionName(i);
				if (this._connections[i].marked) {
					isUsed = true;
				}
			}
			if (isUsed) {
				return this._type + "_" + this._name + conStr + "\n";
			}
			return null;
		},
		ClearMarks: function() {
			for(var i=0;i<this._connections.length; i++) {
				this._connections[i].marked = false;
			}
		},
		_ConnectionName: function(i) {
			if (this._connections[i].fixed) return this._connections[i].fixed;
			return this._type + "_" + this._name + "_" + (i+1);
		}
	};
	this._instruments.push(newinstr);
	return newinstr;
}

visir.Breadboard.prototype._GetAndMarkInstrNodeName = function(p)
{
	for(var i=0;i<this._instruments.length;i++)
	{
		var r = this._instruments[i].GetNameAndMarkIfUsed(p);
		if (r) return r;
	}
	return null;
}

visir.Breadboard.prototype._GetNodeName = function(p)
{
	var px = p.x / 13 | 0;
	var py = p.y / 13 | 0;
	//trace("px/y: " + px + " " + py);

	// upper half, vertical
	if (px >= 11 && px <= 42 && py >= 16 && py <= 20) {	return "A" + (px - 10);	}
	// lower half, vertical
	if (px >= 11 && px <= 42 && py >= 23 && py <= 27) {	return "F" + (px - 10);	}
	// horizontal rows
	if (px >= 13 && px <= 41 && py == 11 && (px % 6 != 0)) { return "X"; }
	if (px >= 13 && px <= 41 && py == 12 && (px % 6 != 0)) { return "Y"; }
	if (px >= 13 && px <= 41 && py == 31 && (px % 6 != 0)) { return "S"; }
	if (px >= 13 && px <= 41 && py == 32 && (px % 6 != 0)) { return "T"; }

	var instrp = this._GetAndMarkInstrNodeName(new visir.Point(px, py));
	if (instrp) return instrp;

	return null;
}

visir.Breadboard.prototype._GenerateCircuit = function()
{
	for(var i=0; i < this._instruments.length; i++) {
		var r = this._instruments[i].ClearMarks();
	}

	var out = "";
	for (var i = 0; i < this._wires.length; i++) {
		var wire = this._wires[i];
		var s = this._GetNodeName(wire._start);
		var e = this._GetNodeName(wire._end);
		if (s && e) out += "W_X " + s + " " + e + "\n";
	}

	for(var i=0;i < this._components.length; i++) {
		var r = this._components[i].GenCircuitIfUsed();
		if (r) out += r;
	}

	for(var i=0; i < this._instruments.length; i++) {
		var r = this._instruments[i].GenInstrIfUsed();
		if (r) out += r;
	}

	return out;
}

visir.Breadboard.prototype.WriteRequest = function()
{
	var $xml = $('<circuit><circuitlist/></circuit>');
	$xml.find("circuitlist").append(this._GenerateCircuit());
	return $("<root />").append($xml).html();
}

visir.Breadboard.prototype.ReadResponse = function()
{

}

visir.Breadboard.prototype.ReadSave = function($xml)
{
	this.LoadCircuit($xml);
}

visir.Breadboard.prototype.WriteSave = function()
{
	return this.SaveCircuit();
}

visir.Breadboard.prototype.LoadCircuit = function(circuit)
{
	this.Clear();
	var me = this;
	if (!this._$library) {
		this._onLibraryLoaded = function() { me.LoadCircuit(circuit); }
		return; // we have to wait until the library is loaded
	}

	var offx = -44;
	var offy = 3;
	
	var $xml = $(circuit);
	$xml.find("component").each(function() {
		var t = $(this).text();
		var args = t.split(" ");
		switch(args[0]) {
			case "W":
				var c = parseInt(args[1], 10);
				var x1 = parseInt(args[2], 10);
				var y1 = parseInt(args[3], 10);
				var x2 = parseInt(args[4], 10);
				var y2 = parseInt(args[5], 10);
				var x3 = parseInt(args[6], 10);
				var y3 = parseInt(args[7], 10);

				var hex = Number(c).toString(16);
				hex = "#" + "000000".substr(0, 6 - hex.length) + hex;

				//trace("wire: " + hex)

				var nWire = new visir.Wire(hex); // XXX
				me._wires.push(nWire);
				nWire._start.x = x1 + offx;
				nWire._start.y = y1 + offy;
				nWire._mid.x = x2 + offx;
				nWire._mid.y = y2 + offy;
				nWire._end.x = x3 + offx;
				nWire._end.y = y3 + offy;

				me._DrawWires();

			break;
			default:
				var x = parseInt(args[2], 10);
				var y = parseInt(args[3], 10);
				var rot = parseInt(args[4], 10);
				var comp = me.CreateComponent(args[0], args[1]);
				comp.Move(x + offx, y + offy);
				comp.Rotate(rot);

			break;
		}
		//trace("xxx: " + $(this).text());
	});
}

visir.Breadboard.prototype._ColorToNum = function(rgb)
{
	var regex = /rgb *\( *([0-9]{1,3}) *, *([0-9]{1,3}) *, *([0-9]{1,3}) *\)/;
	var values = regex.exec(rgb);
	if(!values || values.length != 4)
	{
		return parseInt(rgb.slice(1), 16); // fallback to #000000 format
	}
	var r = Math.round(parseFloat(values[1]));
	var g = Math.round(parseFloat(values[2]));
	var b = Math.round(parseFloat(values[3]));
	return (r << 16) + (g << 8) + b;
}

visir.Breadboard.prototype.SaveCircuit = function(circuit)
{
	var offp = new visir.Point(44, -3);

	var $xml = $("<circuit><circuitlist/></circuit>");

	var $cirlist = $xml.find("circuitlist");
	$cirlist = $xml.find("circuitlist");

	for(var i=0;i<this._wires.length; i++) {
		var w = this._wires[i];
		var $wire = $("<component/>");
		var c = this._ColorToNum(w._color);
		trace("wire color: " + c);
		var s = w._start.Add(offp);
		var m = w._mid.Add(offp);
		var e = w._end.Add(offp);
		$wire.text("W " + c + " " + s.x + " " + s.y + " " + m.x + " " + m.y + " " + e.x + " " + e.y);
		$cirlist.append($wire);
	}

	for(var i=0;i<this._components.length; i++) {
		var c = this._components[i];
		var $comp = $("<component/>");
		var p = c.GetPos().Add(offp);
		$comp.text(c._type + " " + c._value + " " + p.x + " " + p.y + " " + c.GetRotation());
		$cirlist.append($comp);
	}

	return $("<root />").append($xml).html();
}

//////////////////////////////////////////////////////////////////////////////
// Breadboard Instruments handling

visir.Breadboard.prototype._AddInstrumentConnections = function()
{
	this._$elem.find(".instruments .instrument").remove();
	this._AddMultimeters(1 + 13*45,8 + 13*21, (visir.Config) ? visir.Config.GetNrInstrOfType("multimeter") : 2);
	this._AddOSC(1 + 13*45, 8 + 13 * 16,      (visir.Config) ? visir.Config.GetNrInstrOfType("oscilloscope") : 1);
	this._AddDCPower(0, 6+13*5,               (visir.Config) ? visir.Config.GetNrInstrOfType("dcpower") : 1);
	this._AddFGEN(0, 6+13*16,                 (visir.Config) ? visir.Config.GetNrInstrOfType("functiongenerator") : 1);
	this._AddGND(1 + 13*45, 8 + 13 * 30);
}

visir.Breadboard.prototype._AddMultimeters = function(x, y, num)
{
	if (num <= 0) return;
	var i = 0;
	var $dmm = $(
	'<div class="instrument dmm">\
	</div>'
	);

	$dmm.css("left", x + "px").css("top", y + "px");

	for(i=0;i<num; i++) {
		var numstr = ""
		if (num > 1) {
			numstr = (i+1);
			if (i>0) $dmm.append('<div class="connnectionspacer"></div>');
		}

		$dmm.append(
		'<div class="connectionimages">\
			<div class="number">' + numstr + '</div>\
			<img src="' + 	this._BuildImageUrl("connections_2.png") + '" draggable="false" />\
			<div style="height: 11px"></div>\
			<img src="' + 	this._BuildImageUrl("connections_2.png") + '" draggable="false" />\
		</div>'
		);
	}

	$dmm.append(
		'<div class="texts">\
			<div class="connectiontext"></div>\
			<div class="connectiontext">Hi</div>\
			<div class="connectiontext">Lo</div>\
			<div class="connectiontext"></div>\
			<div class="connectiontext">Hi</div>\
			<div class="connectiontext">Lo</div>\
		</div>\
		<div class="title">\
			<div>'+visir.Lang.GetMessage('multimeter')+'</div>\
			<div class="voltage">V/&Omega;</div>\
			<div class="current">mA</div>\
		</div>\
		'
	);

	this._$elem.find(".instruments").append($dmm);

	for(i=0;i<num; i++) {
		var p = new visir.Point(x / 13 | 0, y / 13 | 0);
		var off_x = i * 2;
		this.CreateInstr("DMM", i+1).AddConnection(new visir.Point(p.x + off_x, p.y + 2)).AddConnection(new visir.Point(p.x + off_x, p.y + 3));
		this.CreateInstr("IPROBE", i+1).AddConnection(new visir.Point(p.x + off_x, p.y + 5)).AddConnection(new visir.Point(p.x + off_x, p.y + 6));
	}
}

visir.Breadboard.prototype._AddOSC = function(x, y, num)
{
	if (num <= 0) return;
	var $osc = $(
	'<div class="instrument osc">\
		<div class="connectionimages">\
			<div style="height: 13px"></div>\
			<img src="' + 	this._BuildImageUrl('connections_1.png') + '" draggable="false" />\
			<div style="height: 9px"></div>\
			<img src="' + 	this._BuildImageUrl('connections_1.png') + '" draggable="false" />\
		</div>\
		<div class="texts">\
			<div class="connectiontext"></div>\
			<div class="connectiontext">Ch1</div>\
			<div class="connectiontext"></div>\
			<div class="connectiontext">Ch2</div>\
		</div>\
		<div class="title">'+visir.Lang.GetMessage('oscilloscope')+'</div>\
	</div>'
	);

	$osc.css("left", x + "px").css("top", y + "px");
	this._$elem.find(".instruments").append($osc);

	var p = new visir.Point(x / 13 | 0, y / 13 | 0);
	this.CreateInstr("PROBE1", 1).AddConnection(new visir.Point(p.x, p.y + 2));
	this.CreateInstr("PROBE2", 1).AddConnection(new visir.Point(p.x, p.y + 4));
}

visir.Breadboard.prototype._AddGND = function(x, y)
{
	var $gnd = $(
	'<div class="instrument gnd">\
			<div class="connectionimages">\
				<img src="' + 	this._BuildImageUrl('connections_1.png') + '" />\
			</div>\
			<div class="texts">\
				<div class="connectiontext">GND</div>\
			</div>\
	</div>');
	$gnd.css("left", x + "px").css("top", y + "px");
	this._$elem.find(".instruments").append($gnd);

	var p = new visir.Point(x / 13 | 0, (y / 13 | 0) + 1)
	this.CreateInstr("0").AddConnection(p, "0");
}

visir.Breadboard.prototype._AddDCPower = function(x, y, num)
{
	if (num <= 0) return;

	var dcPower25 = (visir.Config) ? visir.Config.Get("dcPower25") : true;
	var dcPowerM25 = (visir.Config) ? visir.Config.Get("dcPowerM25") : true;
	var dcPower6 = (visir.Config) ? visir.Config.Get("dcPower6") : true;

	var dcPowerHtml = '<div class="instrument dcpower">\
		<div class="title">'+visir.Lang.GetMessage('dc_power')+'</div>\
			<div class="texts">\
				<div class="connectiontext"></div>\n';

	if (dcPower25)
		dcPowerHtml += '<div class="connectiontext">+20V</div>\n';
	else
		dcPowerHtml += '<div class="connectiontext"></div>\n';

	if (dcPower25 || dcPowerM25)
		dcPowerHtml += '<div class="connectiontext">COM</div>\n';
	else
		dcPowerHtml += '<div class="connectiontext"></div>\n';

	if (dcPowerM25) 
		dcPowerHtml += '<div class="connectiontext">-20V</div>\n';
	else
		dcPowerHtml += '<div class="connectiontext"></div>\n';

	dcPowerHtml += '<div class="connectiontext"></div>\n'
 
	if (dcPower6) {
		dcPowerHtml += '<div class="connectiontext">+6V</div>\n';
		dcPowerHtml += '<div class="connectiontext">GND</div>\n';
	} else {
		dcPowerHtml += '<div class="connectiontext"></div>\n';
		dcPowerHtml += '<div class="connectiontext"></div>\n';
	}

	var upperHeight = 0;
	var upperImage = null;
	var lowerHeight = 0;
	var lowerImage = null;

	if (dcPower25) {
		upperHeight = 13;
		if (dcPowerM25) {
			lowerHeight = 10;
			upperImage = this._BuildImageUrl('connections_3.png');
		} else {
			lowerHeight = 10 + 13;
			upperImage = this._BuildImageUrl('connections_2.png');
		}
	} else {
		if (dcPowerM25) {
			upperHeight = 13 + 13;
			lowerHeight = 10;
			upperImage = this._BuildImageUrl('connections_2.png');
		} else {
			// No upperImage: 13 upper + 42 image + 10 lower
			lowerHeight = 13 + 42 + 10;
		}
	}
	if (dcPower6) {
		lowerImage = this._BuildImageUrl('connections_2.png');
	}

	dcPowerHtml += '</div>\
			<div class="connectionimages">\
				<div style="height: ' + upperHeight + 'px"></div>\n';
	if (upperImage != null)
		dcPowerHtml += '<img src="' + upperImage + '" draggable="false" />\n';

	dcPowerHtml += '<div style="height: ' + lowerHeight + 'px"></div>\n';
	if (lowerImage != null) 
		dcPowerHtml += '<img src="' + lowerImage + '" draggable="false" />\n';

	dcPowerHtml += '</div>\n';
	dcPowerHtml += '</div>\n';
	var $dcpower = $(dcPowerHtml);

	$dcpower.css("right", x + "px").css("top", y + "px");
	this._$elem.find(".instruments .left").append($dcpower);

	var p = new visir.Point(x / 13 | 0, y / 13 | 0);
	var off_x = 8;
	var off_y = 9;

	this.CreateInstr("VDC+25V", "1").AddConnection( new visir.Point(p.x + off_x, p.y + off_y + 2));
	this.CreateInstr("VDCCOM", "1").AddConnection( new visir.Point(p.x + off_x, p.y + off_y + 3));
	this.CreateInstr("VDC-25V", "1").AddConnection( new visir.Point(p.x + off_x, p.y + off_y + 4));
	this.CreateInstr("VDC+6V", "1").AddConnection( new visir.Point(p.x + off_x, p.y + off_y + 6));
	this.CreateInstr("0").AddConnection(new visir.Point(p.x + off_x, p.y + off_y + 7), "0");
}

visir.Breadboard.prototype._BuildImageUrl = function(img)
{
	var imageUrl = this.IMAGE_URL + img;

        if (visir.Config.Get("cacheBuster") != null) {
                imageUrl = imageUrl + "?cacheBuster=" + visir.Config.Get("cacheBuster");
        }
	return imageUrl;
}


visir.Breadboard.prototype._AddFGEN = function(x, y, num)
{
	if (num <= 0) return;
	var $fgen = $(
	'<div class="instrument fgen">\
		<div class="texts">\
			<div class="connectiontext"></div>\
			<div class="connectiontext">'+visir.Lang.GetMessage('func_gen')+'</div>\
			<div class="connectiontext">GND</div>\
		</div>\
		<div class="connectionimages">\
			<div style="height: 13px"></div>\
			<img src="' + 	this._BuildImageUrl('connections_2.png') + '" draggable="false" />\
		</div>\
	</div>'
	);

	$fgen.css("right", x + "px").css("top", y + "px");
	this._$elem.find(".instruments .left").append($fgen);

	var p = new visir.Point(x / 13 | 0, y / 13 | 0);
	var off_x = 8;
	var off_y = 9;
	this.CreateInstr("VFGENA", 1).AddConnection( new visir.Point(p.x + off_x, p.y + off_y + 2)).AddConnection(new visir.Point(1000,1000),"0");
	this.CreateInstr("0").AddConnection(new visir.Point(p.x + off_x, p.y + off_y + 3), "0");
};

"use strict";
var visir = visir || {};

visir.FlukeMultimeter = function(id, elem)
{
	//"off", "ac volts", "dc volts", "off", "resistance", "off", "ac current", "dc current");
	//var rotFuncMap = { 345: "off", 15: "ac volts", 45: "dc volts", 75: "off", 105: "resistance", 135: "off", 165: "ac current", 195: "dc current"};

	var dmm = this;
	this._elem = elem;
	this._result = "";

	visir.FlukeMultimeter.parent.constructor.apply(this, arguments)

	var imgbase = "instruments/flukemultimeter/";
	if (visir.BaseLocation) imgbase = visir.BaseLocation + imgbase;

	var tpl = '<div class="flukedmm">\
	<img src="' + imgbase + 'fluke23.png" width="300" height="460" draggable="false" />\
	<div class="display">\
		<div class="dmm_value" id="value">12.3</div>\
		<div class="mode AC">VAC</div>\
		<div class="mode DC">VDC</div>\
		<div class="mode Ohm">&#8486;</div>\
		<div class="unit"></div>\
	</div>\
	<div class="rot">\
		<div class="top vred">\
			<img src="' + imgbase + 'fluke23_vred.png" alt="handle" />\
		</div>\
	</div>\
	<div class="manual_link"><a href="http://assets.fluke.com/manuals/23______omeng0000.pdf" target="_blank">%downloadManual%</a></div>\
	</div>';

	tpl = tpl.replace(/%downloadManual%/g, visir.Lang.GetMessage("down_man"));
	elem.append(tpl);

	var top = elem.find(".top");
	setRotation(top, 345);

	var handle = elem.find(".rot");

	function handleTurn(elem, deg)
	{
		if (!visir.Config.Get("readOnly"))
		{
			deg = ( deg - deg % 30 )  + 15;

			if (deg <= 105 || deg >= 255)
			{
				setRotation(top, deg);

				var rotFuncMap = { 255: "off", 285: "ac volts", 315: "dc volts", 345: "off", 15: "resistance", 45: "off", 75: "ac current", 105: "dc current"};
				var mode = rotFuncMap[deg];
				dmm.SetMode(mode);
				
				if (mode == "off") dmm._result = "";
				else if (mode == "resistance") dmm._result = "OL";
				else dmm._result = 0.0;

				dmm.UpdateDisplay();
				return deg;
			}
		}
		return undefined; // don't set a new rotation
	}

	handle.turnable({ offset: 90, turn: handleTurn })

	dmm.UpdateDisplay();
}

extend(visir.FlukeMultimeter, visir.Multimeter)

visir.FlukeMultimeter.prototype.Test = function() {

}

visir.FlukeMultimeter.prototype.UpdateDisplay = function() {
	if (this.GetMode() == "off") {
		this._elem.find(".display").toggle(false);		
		return;
	}
	
	this._elem.find(".display").toggle(true);
	this._elem.find(".display .mode").toggle(false);
	
	var result = this.GetResult();
	var unit = "";
	var out = 0.0;
	
	if (isNaN(result)) {
		out = "OL"; unit = "M";
	}	else {
		var unitinfo = this._GetUnit(result);
		out = result / Math.pow(10, unitinfo.pow);
		out = out.toPrecision(4);
		unit = unitinfo.unit;
	}
		
	this._elem.find(".dmm_value").text(out);
	
	switch(this.GetMode())
	{
		case "ac volts":
			this._elem.find(".display .mode.AC").toggle(true).text( unit + "VAC");
			break;
		case "dc volts":
			this._elem.find(".display .mode.DC").toggle(true).text( unit +"VDC");
			break;
		case "resistance":
			this._elem.find(".display .mode.Ohm").toggle(true).html( unit + '&#8486;');
			break;
		case "ac current":
			this._elem.find(".display .mode.AC").toggle(true).text( unit + "AC");
			break;
		case "dc current":
			this._elem.find(".display .mode.DC").toggle(true).text( unit + "DC");
			break;
	}
}

visir.FlukeMultimeter.prototype.ReadResponse = function(response) {
	visir.FlukeMultimeter.parent.ReadResponse.apply(this, arguments)
	this.UpdateDisplay();
}

visir.FlukeMultimeter.prototype._GetUnit = function(val)
{
	var units = [
		["G", 6 ]
		, ["M", 6 ]
		, ["k", 3 ]
		, ["", 0]
		, ["m", -3]
		, ["u", -6]
		, ["n", -9]
		];
	val = Math.abs(val);
	var unit = "";
	var div = 0;
	if (val == 0) return { unit: unit, pow: div };

	for (var key in units) {
		var unit = units[key];
		if (val >= Math.pow(10, unit[1])) {
			return {unit: unit[0], pow: unit[1] };
		}
	}

	var last = units[units.length - 1];
	return {unit: last[0], pow: last[1] };
}

visir.FlukeMultimeter.prototype.ReadSave = function($xml)
{
	var $multimeter = $xml.find("multimeter[id='" + this._id + "']");
	if ($multimeter.length == 1) {
		var mode = $multimeter.attr("mode");
		this.SetMode(mode);

		switch (mode) {
			case 'ac volts':
			  setRotation(this._elem.find(".top"), 15);
			  break;
			case 'dc volts':
			  setRotation(this._elem.find(".top"), 45);
			  break;
			case 'resistance':
			  setRotation(this._elem.find(".top"), 105);
			  break;
			case 'ac current':
			  setRotation(this._elem.find(".top"), 165);
			  break;
			case 'dc current':
			  setRotation(this._elem.find(".top"), 195);
			  break;
			default:
			  setRotation(this._elem.find(".top"), 345);
			  break;
		}
		this.UpdateDisplay();
	}
}

visir.FlukeMultimeter.prototype.WriteSave = function()
{
	return $("<multimeter id='" + this._id + "'></multimeter>").attr("mode", this.GetMode());
};

"use strict";

var visir = visir || {};

visir.TripleDC = function(id, elem)
{
	visir.TripleDC.parent.constructor.apply(this, arguments)

	this._elem = elem;
	this._id = id;

	this._Redraw([0, 0, 0]);
};

extend(visir.TripleDC, visir.DCPower)

visir.TripleDC.prototype._Redraw = function (initialValue) 
{
	var me = this;
	var dcPower25 = (visir.Config) ? visir.Config.Get("dcPower25") : true;
	var dcPowerM25 = (visir.Config) ? visir.Config.Get("dcPowerM25") : true;
	var dcPower6 = (visir.Config) ? visir.Config.Get("dcPower6") : true;

	this.dcPower6 = dcPower6;
	this.dcPower25 = dcPower25;
	this.dcPowerM25 = dcPowerM25;

	this._elem.empty();

	if (dcPower6) {
		this._activeChannel = "6V+";
	} else if (dcPower25) {
		this._activeChannel = "25V+";
	} else if (dcPowerM25) {
		this._activeChannel = "25V-";
	} else {
		// No dcPower?
		return;
	}

	// all the values are represented times 1000 to avoid floating point trouble
	// XXX: need to change this later, both voltage and current has an active digit
	this._values = {
		"6V+": { voltage: 0, current: 5000, digit: 2, min: 0, max: 6000},
		"25V+": { voltage: 0, current: 5000, digit: 2, min: 0, max: 25000 },
		"25V-": { voltage: 0, current: 5000, digit: 2, min: -25000, max: 0 }
	 }

	var imgbase = "instruments/tripledc/images";
	if (visir.BaseLocation) imgbase = visir.BaseLocation + imgbase;

	var tpl = '<div class="tripledc">\
	<img src="%img%/3dc.png" width="720" height="449" draggable="false" />\
	<div class="bigtext voltage"><span class="green">0</span>.000V</div>\
	<div class="bigtext current">0.500A</div>\
	<div class="channelselect">\n'

	if (dcPower6) {
		tpl += '<div class="smalltext p6v">+6V</div>';
	}

	if (dcPower25) {
		if (this._activeChannel == "25V+") {
			tpl += '<div class="smalltext p25v">+25V</div>';
		} else {
			tpl += '<div class="smalltext p25v hide">+25V</div>';
		}
	}

	if (dcPowerM25) {
		if (this._activeChannel == "25V-") {
			tpl += '<div class="smalltext m25v">-25V</div>';
		} else {
			tpl += '<div class="smalltext m25v hide">-25V</div>';
		}
	}
	tpl += '</div>\n';
	if (dcPower6) {
		tpl += '<div class="button button_p6v"><img class="up active" src="%img%/6v_up.png" alt="+6v button" /><img class="down" src="%img%/6v_down.png" alt="+6v button" /></div>\n';
	}
	if (dcPower25) {
		tpl += '<div class="button button_p25v"><img class="up active" src="%img%/25plusv_up.png" alt="+25v button" /><img class="down" src="%img%/25plusv_down.png" alt="+25v button" /></div>\n';
	}
	if (dcPowerM25) {
		tpl += '<div class="button button_m25v"><img class="up active" src="%img%/25minusv_up.png" alt="-25v button" /><img class="down" src="%img%/25minusv_down.png" alt="-25v button" /></div>\n';
	}
	tpl += '<div class="button button_left"><img class="up active" src="%img%/arrowleft_up.png" alt="left button" /><img class="down" src="%img%/arrowleft_down.png" alt="left button" /></div>\
	<div class="button button_right"><img class="up active" src="%img%/arrowright_up.png" alt="right button" /><img class="down" src="%img%/arrowright_down.png" alt="right button" /></div>\
	<div class="knob">\
		<div class="top">\
			<img src="%img%/3dc_wheel.png" alt="handle" />\
		</div>\
	</div>\
	<div class="manual_link"><a href="http://cp.literature.agilent.com/litweb/pdf/E3631-90002.pdf" target="_blank">%downloadManual%</a></div>\
	</div>';

	tpl = tpl.replace(/%img%/g, imgbase);
	tpl = tpl.replace(/%downloadManual%/g, visir.Lang.GetMessage("down_man"));

	this._elem.append(tpl);

	if (dcPower6) {
		this._SetInitialValue("6V+", Number(initialValue[0]), 2);
	}
	if (dcPower25) {
		this._SetInitialValue("25V+", Number(initialValue[1]), 2);
	}
	if (dcPowerM25) {
		this._SetInitialValue("25V-", Number(initialValue[2]), 2);
	}
	if (dcPower6) {
		this._SetActiveChannel("6V+");
		this._activeChannel = "6V+";
	} else if (dcPower25) {
		this._SetActiveChannel("25V+");
		this._activeChannel = "25V+";
	} else if (dcPowerM25) {
		this._SetActiveChannel("25V-");
		this._activeChannel = "25V-";
	}

	var $doc = $(document);

	var prev = 0;

	function handleTurn(elem, deg) {
		var diff = deg - prev;
		// fixup the wrapping
		if (diff > 180) diff = -360 + diff;
		else if (diff < -180) diff = 360 + diff;

		if (Math.abs(diff) > 360/10) {
			prev = deg;
			//trace("diff: " + diff);
			if (diff < 0) me._DecDigit();
			else if (diff > 0) me._IncDigit();
		}

		return deg;
	}

	if(!visir.Config.Get("readOnly"))
	{
		this._elem.find(".knob").turnable({offset: 90, turn: handleTurn });

		// make all buttons updownButtons
		this._elem.find(".button").updownButton();

		this._elem.find("div.button_p6v").click( function() {
			me._SetActiveChannel("6V+");
		});
		this._elem.find("div.button_p25v").click( function() {
			me._SetActiveChannel("25V+");
		});
		this._elem.find("div.button_m25v").click( function() {
			me._SetActiveChannel("25V-");
		});
		this._elem.find("div.button_left").click( function() {
				var aCh = me._GetActiveChannel();
				trace("digit: " + (aCh.digit + 1));
				me._SetActiveValue(aCh.voltage, aCh.digit + 1);
		});
		this._elem.find("div.button_right").click( function() {
				var aCh = me._GetActiveChannel();
				trace("digit: " + (aCh.digit -1));
				me._SetActiveValue(aCh.voltage, aCh.digit - 1);
		});
	}

	// XXX: need to fix this when making it possible to change current limits
	var blink = this._elem.find(".tripledc .voltage");
	setInterval(function() {
		blink.toggleClass("on");
	},500);

	me._UpdateDisplay();
};

visir.TripleDC.prototype._UpdateDisplay = function(showMeasured) {
	showMeasured = showMeasured || false;
	var aCh = this._GetActiveChannel();
	var digitoffset = 0;
	if (aCh.voltage >= 10000) {
		digitoffset = 1;
	}

	var value = 0;
	if (showMeasured) {
		var responseData = this._channels[this._activeChannel];
		if (!responseData.enabled) return;
		value = responseData.measured_voltage;
		if (value == 0.0) return;
	} else {
		value = (aCh.voltage / 1000);
	}

	//var value = (showMeasured) ? this._channels[this._activeChannel].measured_voltage : (aCh.voltage / 1000);
	trace("value: " + value);

	//var fixed = (aCh.voltage >= 10000) ? 2 : 3;
	//var num = (aCh.voltage / 1000).toFixed(3 - digitoffset);
	var num = value.toFixed(3 - digitoffset);
	this._elem.find(".voltage").html(visir.LightNum(num, aCh.digit - digitoffset) + "V" );
}

visir.TripleDC.prototype._GetActiveChannel = function() {
	return this._values[this._activeChannel];
}

visir.TripleDC.prototype._SetActiveChannel = function(ch) {
	trace("activechannel: " + ch);
	this._activeChannel = ch;

	this._elem.find(".channelselect > div").addClass("hide");
	var show = "";
	switch(ch) {
		case "6V+": show = "p6v"; break;
		case "25V+": show = "p25v"; break;
		case "25V-": show = "m25v"; break;
		default: show = "p6v";
	}
	this._elem.find(".channelselect > div." + show).removeClass("hide");
	this._UpdateDisplay();
}

visir.TripleDC.prototype._SetActiveValue = function(val, digit) {
	var aCh = this._GetActiveChannel();
	if ((val < aCh.min) || (val > aCh.max)) return;
	if (digit > 4 || digit < 0) return;
	//trace("setactivevalue: " + val + " " + digit + " " + Math.pow(10, digit));
	if (val > 1000 && val < Math.pow(10, digit)) return;
	if (val < 10000 && digit == 4) return;
	aCh.voltage = val;
	aCh.digit = digit;
	this.GetChannel(this._activeChannel).voltage = (val / 1000);
	this._UpdateDisplay();
}

visir.TripleDC.prototype._DecDigit = function() {
	var aCh = this._GetActiveChannel();
	this._SetActiveValue(aCh.voltage - Math.pow(10, aCh.digit), aCh.digit);
}

visir.TripleDC.prototype._IncDigit = function() {
	var aCh = this._GetActiveChannel();
	this._SetActiveValue(aCh.voltage + Math.pow(10, aCh.digit), aCh.digit);
}

visir.TripleDC.prototype.ReadResponse = function(response) {
	var me = this;
	visir.TripleDC.parent.ReadResponse.apply(this, arguments);

	this._UpdateDisplay(true);
}

visir.TripleDC.prototype._ReadCurrentValues = function() {
	/* Only used if unrFormat = true */
	var volts = "";
	volts = this._channels["6V+"].voltage * 1000 + ":" + this._channels["25V+"].voltage  * 1000 + ":" + this._channels["25V-"].voltage  * 1000;
	return volts;
}

visir.TripleDC.prototype._SetInitialValue = function(ch, val, digit) {
	this._activeChannel = ch;
	this._SetActiveValue(val,digit);
}

visir.TripleDC.prototype.ReadSave = function($xml)
{
	var initialValue = [0, 0, 0];

	// Only for backwards compatibility
	var $instrumentsvalues = $xml.find("instrumentsvalues");
	if ($instrumentsvalues.length == 1) {
		var htmlinstrumentsvalues = $instrumentsvalues.attr("htmlinstrumentsvalues");
		if (htmlinstrumentsvalues) {
			$.each(htmlinstrumentsvalues.split("|"), function (pos, instrumentData) {
				var instrumentName = instrumentData.split("#")[0];
				if (instrumentName == "TripleDC") {
					var numbers = instrumentData.split("#")[1].split(":");
					initialValue = [ parseInt(numbers[0]), parseInt(numbers[1]), parseInt(numbers[2]) ];
				}
			});
		}
	}

	if (this.dcPower6) {
		var $dcPower6voltage = $xml.find("dc_output[channel='6V+']");
		if ($dcPower6voltage.length == 1) {
			initialValue[0] = Number($dcPower6voltage.attr("value"));
		}
	}

	if (this.dcPower25) {
		var $dcPower25voltage = $xml.find("dc_output[channel='25V+']");
		if ($dcPower25voltage.length == 1) {
			initialValue[1] = Number($dcPower25voltage.attr("value"));
		}
	}

	if (this.dcPowerM25) {
		var $dcPowerM25voltage = $xml.find("dc_output[channel='25V-']");
		if ($dcPowerM25voltage.length == 1) {
			initialValue[2] = Number($dcPowerM25voltage.attr("value"));
		}
	}

	this._Redraw(initialValue);
}

visir.TripleDC.prototype.WriteSave = function()
{
	var $xml = $("<dcpower></dcpower>");
	if (this.dcPower6) {
		var channel = $("<dc_output channel=\"6V+\" value=\"" + (this._channels["6V+"].voltage * 1000) + "\"/>");
		$xml.append(channel);
	}
	if (this.dcPower25) {
		var channel = $("<dc_output channel=\"25V+\" value=\"" + (this._channels["25V+"].voltage * 1000) + "\"/>");
		$xml.append(channel);
	}
	if (this.dcPowerM25) {
		var channel = $("<dc_output channel=\"25V-\" value=\"" + (this._channels["25V-"].voltage * 1000) + "\"/>");
		$xml.append(channel);
	}
	return $xml;
};

"use strict";

var visir = visir || {};

visir.HPFunctionGenerator = function(id, elem)
{
	visir.HPFunctionGenerator.parent.constructor.apply(this, arguments)

	var me = this;
	this._$elem = elem;
	this._currentValue = "freq";

	this.ENTERNUM = 1;
	this.NORMAL = 0;
	this._enterMode = this.NORMAL;
	this._enterNumStr = "";

	/* the multipliers are used to avoid storing the values in floating point
	which will cause problems when trying to display the values */
	this._values = {
		"freq": { value: 1000 * 100000000, multiplier: 100000000, digit: 8, numDigits: 8, unit: "Hz", max: 1*1000*1000*100000000, min: 10000},
		"ampl": { value: 1 * 10000, multiplier: 10000, digit: 4, numDigits: 4, unit: "Vpp", max: 10*10000, min: 500 },
		"offset": { value: 0, multiplier: 10000, digit: 4, numDigits: 4, unit: "VDC", max: 10*10000, min: -10*10000 }
	 }

	var imgbase = "instruments/hp_funcgen/images";
	if (visir.BaseLocation) imgbase = visir.BaseLocation + imgbase;

	var tpl =
	'<div class="hp_funcgen">\
	<img src="%img%/fgen.png" width="800" height="356" draggable="false" />\
	<div class="bigtext num_display">1.00<span class="green">0</span>0000</div>\
	<div class="bigtext num_unit">KHz</div>\
	<div class="funcselect">\
		<img class="sine active" src="%img%/sine.svg" alt="sine" />\
		<img class="square" src="%img%/square.svg" alt="square" />\
		<img class="triangle" src="%img%/tri.svg" alt="triangle" />\
		<img class="rampup" src="%img%/saw.svg" alt="sawtooth" />\
	</div>\
	<div class="button button_sine"><img class="up active" src="%img%/reflad_sin_up.png" alt="sine button" /><img class="down" src="%img%/reflad_sin_down.png" alt="sine button" /></div>\
	<div class="button button_square"><img class="up active" src="%img%/reflad_square_up.png" alt="square button" /><img class="down" src="%img%/reflad_square_down.png" alt="square button" /></div>\
	<div class="button button_triangle"><img class="up active" src="%img%/reflad_tri_up.png" alt="tri button" /><img class="down" src="%img%/reflad_tri_down.png" alt="tri button" /></div>\
	<div class="button button_rampup"><img class="up active" src="%img%/reflad_saw_up.png" alt="saw button" /><img class="down" src="%img%/reflad_saw_down.png" alt="saw button" /></div>\
	<div class="button button_noise"><img class="up active" src="%img%/reflad_noise_up.png" alt="noise button" /><img class="down" src="%img%/reflad_noise_down.png" alt="noise button" /></div>\
	<div class="button button_arb"><img class="up active" src="%img%/reflad_arb_up.png" alt="arb button" /><img class="down" src="%img%/reflad_arb_down.png" alt="arb button" /></div>\
	<div class="button button_enter"><img class="up active" src="%img%/enter_up.png" alt="enter button" /><img class="down" src="%img%/enter_down.png" alt="enter button" /></div>\
	<div class="button button_freq"><img class="up active" src="%img%/ren_freq_up.png" alt="freq button" /><img class="down" src="%img%/ren_freq_down.png" alt="freq button" /></div>\
	<div class="button button_ampl"><img class="up active" src="%img%/ren_ampl_up.png" alt="ampl button" /><img class="down" src="%img%/ren_ampl_down.png" alt="ampl button" /></div>\
	<div class="button button_offset"><img class="up active" src="%img%/ren_offset_up.png" alt="offset button" /><img class="down" src="%img%/ren_offset_down.png" alt="offset button" /></div>\
	<div class="button button_single"><img class="up active" src="%img%/ren_single_up.png" alt="single button" /><img class="down" src="%img%/ren_single_down.png" alt="single button" /></div>\
	<div class="button button_recall"><img class="up active" src="%img%/ren_recall_up.png" alt="recall button" /><img class="down" src="%img%/ren_recall_down.png" alt="recall button" /></div>\
	<div class="button button_enternumber"><img class="up active" src="%img%/ren_enternumber_up.png" alt="enternumber button" /><img class="down" src="%img%/ren_enternumber_down.png" alt="enternumber button" /></div>\
	<div class="button button_shift"><img class="up active" src="%img%/shift_up.png" alt="shift button" /><img class="down" src="%img%/shift_down.png" alt="shift button" /></div>\
	<div class="button button_up"><img class="up active" src="%img%/small_up_up.png" alt="up button" /><img class="down" src="%img%/small_up_down.png" alt="up button" /></div>\
	<div class="button button_down"><img class="up active" src="%img%/small_down_up.png" alt="down button" /><img class="down" src="%img%/small_down_down.png" alt="down button" /></div>\
	<div class="button button_right"><img class="up active" src="%img%/small_right_up.png" alt="right button" /><img class="down" src="%img%/small_right_down.png" alt="right button" /></div>\
	<div class="button button_left"><img class="up active" src="%img%/small_left_up.png" alt="left button" /><img class="down" src="%img%/small_left_down.png" alt="left button" /></div>\
	<div class="knob">\
		<div class="top">\
			<img src="%img%/wheel.png" alt="handle" />\
		</div>\
	</div>\
	<div class="manual_link"><a href="http://www.home.agilent.com/upload/cmc_upload/All/6C0633120A_USERSGUIDE_ENGLISH.pdf" target="_blank">%downloadManual%</a></div>\
	</div>';

	tpl = tpl.replace(/%img%/g, imgbase);
	tpl = tpl.replace(/%downloadManual%/g, visir.Lang.GetMessage("down_man"));
	//console.log(tpl);

	elem.append(tpl);

	this._SetInitialValue("freq", 0, 8);
	this._SetInitialValue("ampl", 0, 4);
	this._SetInitialWaveform("sine");
	this.SetActiveValue("freq");

	var $doc = $(document);

	var prev = 0;

	function handleTurn(elem, deg) {
		var diff = deg - prev;
		// fixup the wrapping
		if (diff > 180) diff = -360 + diff;
		else if (diff < -180) diff = 360 + diff;

		if (Math.abs(diff) > 360/10) {
			prev = deg;
			//trace("diff: " + diff);
			if (diff < 0) me._DecDigit();
			else if (diff > 0) me._IncDigit();
		}

		return deg;
	}

	function buttonPressGen(name) {
		return function() {
			me._ButtonPressed(name);
		}
	}

	if(!visir.Config.Get("readOnly"))
	{
		elem.find(".knob").turnable({offset: 90, turn: handleTurn });

		// make all buttons updownButtons
		elem.find(".button").updownButton();

		var buttons = [ "sine", "square", "triangle", "rampup", "noise",
			"arb", "enter", "freq", "ampl", "offset",
			"single", "recall", "enternumber", "shift", "up",
			"down", "right", "left"] ;

		for (var i in buttons) {
			elem.find("div.button_" + buttons[i]).click( buttonPressGen(buttons[i]) );
		}
	}

	var blink = elem.find(".hp_funcgen .num_display");
	setInterval(function() {
		blink.toggleClass("on");
	},500);

	me._UpdateDisplay();
}

extend(visir.HPFunctionGenerator, visir.FunctionGenerator)


function numDigits(val)
{
	val = Math.abs(val);
	var out = 1;
	var t = 10;
	while(val >= t) {
		t *= 10;
		out++;
	}
	return out;
}

/*
function CountNum(str)
{
	var cnt = 0;
	for(var i in str) {
		if (str[i] >= '0' && str[i] <= '9') cnt++;
	}
	return cnt;
}

function GetLightNumOffset(value, digits)
{
	var num = CountNum(value.toFixed(digits));
	return num - digits;
}*/

visir.HPFunctionGenerator.prototype._SetButtonMode = function(mode)
{
	this._enterMode = mode;
	this._enterNumStr = "";
}

visir.HPFunctionGenerator.prototype._AddNum = function(char)
{
	if (this._enterNumStr.length > this._values[this._currentValue].numDigits) return false;
	if ((char == '.') && (this._enterNumStr.indexOf(".") >= 0)) return false;
	this._enterNumStr += char;
}

visir.HPFunctionGenerator.prototype._RemoveNum = function()
{
	if (this._enterNumStr.length == 0) return false;
	this._enterNumStr = this._enterNumStr.slice(0, -1);
}

visir.HPFunctionGenerator.prototype._NumSign = function()
{
	// not implemented
}

visir.HPFunctionGenerator.prototype._SetEnteredNumber = function(scale)
{
	var num = Number(this._enterNumStr, 10);
	var val = this._values[this._currentValue];

	this._SetActiveValue(num * val.multiplier * scale, val.digit);
	this._SetButtonMode(this.NORMAL);
}

visir.HPFunctionGenerator.prototype._ButtonPressed = function(buttonName)
{
	if (this._enterMode == this.NORMAL) this._NormalButtonPressed(buttonName);
	else this._EnterNumButtonPressed(buttonName);

	this._UpdateDisplay();
}

visir.HPFunctionGenerator.prototype._NormalButtonPressed = function(buttonName)
{
	switch(buttonName) {
		case "sine": this.SetWaveform("sine"); this._UpdateDisplay(); break;
		case "square": this.SetWaveform("square"); this._UpdateDisplay(); break;
		case "triangle": this.SetWaveform("triangle"); this._UpdateDisplay(); break;
		case "rampup": this.SetWaveform("rampup"); this._UpdateDisplay(); break;
		
		case "freq": this.SetActiveValue("freq"); break;
		case "ampl": this.SetActiveValue("ampl"); break;
		case "offset": this.SetActiveValue("offset"); break;
		
		case "right":
			var val = this._values[this._currentValue];
			this._SetActiveValue(val.value, val.digit - 1);
			break;
		case "left":
			var val = this._values[this._currentValue];
			this._SetActiveValue(val.value, val.digit + 1);
			break;
		
		case "up": this._IncDigit(); break;
		case "down": this._DecDigit(); break;

		case "enternumber": this._SetButtonMode(this.ENTERNUM); break;

		default:
			trace("unknown button in normal mode: " + buttonName);
			break;
	}
}

visir.HPFunctionGenerator.prototype._EnterNumButtonPressed = function(buttonName)
{
	var mega = 1;
	var kilo = 1;
	var uni = 1;
	switch(this._currentValue) {
		case "freq": mega = 1000000; kilo = 1000; uni = 1; break;
		case "ampl": mega = 1; kilo = 2.829; uni = 0.7096; break;
		case "offset": mega = 1; kilo = 1; uni = 1; break;
	}
	switch(buttonName) {
		case "sine":	this._AddNum("1"); break;
		case "square":	this._AddNum("2"); break;
		case "triangle":	this._AddNum("3"); break;
		case "rampup":	this._AddNum("4"); break;
		case "noise":	this._AddNum("5"); break;
		case "freq":	this._AddNum("6"); break;
		case "ampl":	this._AddNum("7"); break;
		case "offset":	this._AddNum("8"); break;
		case "single":	this._AddNum("9"); break;
		case "recall":	this._AddNum("0"); break;

		case "enternumber": this._AddNum(".");	break;

		case "left":	this._RemoveNum();	break;		
		case "arb": 	this._NumSign();		break;

		case "enter":	this._SetEnteredNumber(1);	break;

		case "up":		this._SetEnteredNumber(mega);	break;
		case "down":	this._SetEnteredNumber(kilo); break;
		case "right":	this._SetEnteredNumber(uni); break;
		default:
			trace("unknown button in enter number mode: " + buttonName);
			break;		
	}
}

visir.HPFunctionGenerator.prototype._GetDisplayDigitInfo = function(realval, digits, activedigit, valunit)
{
	var unit = this._GetUnit(realval);
	realval /= Math.pow(10, unit.pow); // compensate for prefixes

	var num = numDigits(realval); // count the number of digits before .
	var display = realval.toFixed(digits - num);
	var prefixedunit = unit.unit + valunit;
	var digit = activedigit - unit.pow - num;

	return { display: display, unit: prefixedunit, digit: digit };
}

visir.HPFunctionGenerator.prototype._UpdateDisplay = function(ch)
{
	// show the selected waveform indicator
	this._$elem.find(".funcselect img").removeClass("active");
	var set = this.GetWaveform();
	switch(set) {
		case "rampup": set = "rampup"; break;
		case "rampdown": set = "rampup"; break;
	}
	this._$elem.find(".funcselect img." + set).addClass("active");

	// display the selected value
	var val = this._values[this._currentValue];
	/*
	var realval = val.value / val.multiplier;
	var unit = GetUnit(realval);
	realval /= Math.pow(10, unit.pow);
	//trace("X:" + realval + " " + numDigits(realval) + " " + val.value + " " + val.digit);

	var len = val.numDigits;
	var num = numDigits(realval);
	var digitoffset = unit.pow;
	var out = realval.toFixed(len - num);
	*/

	if (this._enterMode == this.NORMAL) {
		var info = this._GetDisplayDigitInfo(val.value / val.multiplier, val.numDigits, val.digit, val.unit);
		this._$elem.find(".num_display").html(visir.LightNum(info.display, info.digit));
		if (info.unit === "Vpp" && !visir.Config.Get("vppInFuncgen")) {
			this._$elem.find(".num_unit").html("Vp ");
		} else {
			this._$elem.find(".num_unit").html(info.unit);
		}
	} else {
		this._$elem.find(".num_display").html(this._enterNumStr);
		this._$elem.find(".num_unit").html("");
	}

	/*this._$elem.find(".num_display").html(visir.LightNum(out, val.digit - digitoffset - num));

	var unitprefix = unit.unit;
	this._$elem.find(".num_unit").html(unitprefix + val.unit);
	*/
}

visir.HPFunctionGenerator.prototype.SetActiveValue = function(val)
{
	this._currentValue = val;
	this._UpdateDisplay();
}

visir.HPFunctionGenerator.prototype._GetUnit = function(val)
{
	var units = [
		, ["M", 6 ]
		, ["K", 3 ]
		, ["", 0]
		];
	val = Math.abs(val);
	var unit = "";
	var div = 0;
	if (val == 0) return { unit: unit, pow: div };

	for (var key in units) {
		var unit = units[key];
		if (val >= Math.pow(10, unit[1])) {
			return {unit: unit[0], pow: unit[1] };
		}
	}

	var last = units[units.length - 1];
	return {unit: last[0], pow: last[1] };
}

visir.HPFunctionGenerator.prototype._SetActiveValue = function(value, digit) {
	trace("SetActiveValue: " + value + " " + digit);
	var val = this._values[this._currentValue];

	var ok = true;
	if (value > val.max || value < val.min)	ok = false;

	trace("XXX: " + Math.pow(10, digit) + " " + value + " " + (value / val.multiplier));

	// test if active digit is outside display range (upper bound)
	if ((Math.abs(value / val.multiplier) >= 1.0) && (Math.pow(10, digit) > Math.abs(value))) ok = false;
	// XXX: lower bounds check of digit should check if the active digit will still be visible after update

	var info = this._GetDisplayDigitInfo(value / val.multiplier, val.numDigits, digit, "");
	if (info.digit < 0) ok = false;

	if (ok) {
		val.digit = digit;
		val.value = value;

		var realvalue = val.value / val.multiplier;
		switch(this._currentValue) {
			case "freq": this._frequency = realvalue; break;
			case "ampl": this._amplitude = realvalue; break;
			case "offset": this._offset = realvalue; break;
			default:
				throw "Unknown value type";
		}
	}
	this._UpdateDisplay();
}


visir.HPFunctionGenerator.prototype._DecDigit = function() {
	var val = this._values[this._currentValue];
	var tmp = val.value - Math.pow(10, val.digit);
	this._SetActiveValue(tmp, val.digit);
}

visir.HPFunctionGenerator.prototype._IncDigit = function() {
	var val = this._values[this._currentValue];
	//val.value += Math.pow(10, val.digit);
	var tmp = val.value + Math.pow(10, val.digit);
	this._SetActiveValue(tmp, val.digit);
}

visir.HPFunctionGenerator.prototype._ReadCurrentValues = function() {
	/* if unrFormat is true */
	var volts = "";
	volts = this._values["freq"].value + ":" + this._values["ampl"].value + ":" + this.GetWaveform();
	return volts;
}

visir.HPFunctionGenerator.prototype._SetInitialValue = function(ch, val, digit) {
	this._currentValue = ch;
	this._SetActiveValue(val, digit);
}

visir.HPFunctionGenerator.prototype._SetInitialWaveform = function(wave) {
	this.SetWaveform(wave);
	this._UpdateDisplay();
}

visir.HPFunctionGenerator.prototype.ReadSave = function ($xml) {
	var me = this;

	// Only for backwards compatibility
	var $instrumentsvalues = $xml.find("instrumentsvalues");
	if ($instrumentsvalues.length == 1) {
		var htmlinstrumentsvalues = $instrumentsvalues.attr("htmlinstrumentsvalues");
		if (htmlinstrumentsvalues) {
			$.each(htmlinstrumentsvalues.split("|"), function (pos, instrumentData) {
				var instrumentName = instrumentData.split("#")[0];
				if (instrumentName == "HPFunctionGenerator") {
					var numbers = instrumentData.split("#")[1].split(":");
					
					var freq = Number(numbers[0]);
					var ampl = Number(numbers[1]);
					var wave = numbers[2];

					me.SetWaveform(wave);
					me._SetInitialValue("ampl", ampl, 4);
					me._SetInitialValue("freq", freq, 8);

					me._UpdateDisplay();
				}
			});
		}
	}

	// Overwritten with the new format if available
	var $currentFunctionGenerator = $xml.find("functiongenerator[id='" + this._id + "']");
	if ($currentFunctionGenerator.length == 1) {
		var wave = $currentFunctionGenerator.attr("wave");
		var ampl = Number($currentFunctionGenerator.attr("ampl"));
		var freq = Number($currentFunctionGenerator.attr("freq"));

		this.SetWaveform(wave);
		this._SetInitialValue("ampl", ampl, 4);
		this._SetInitialValue("freq", freq, 8);

		this._UpdateDisplay();
	}
};

visir.HPFunctionGenerator.prototype.WriteSave = function () {
	var $functiongenerator = $("<functiongenerator></functiongenerator>").attr("id", this._id);
	$functiongenerator.attr("freq", this._values["freq"].value);
	$functiongenerator.attr("ampl", this._values["ampl"].value);
	$functiongenerator.attr("wave", this.GetWaveform());
	return $functiongenerator;
};

/*global trace, extend */
/*jshint laxcomma:true, multistr:true */

"use strict";
var visir = visir || {};

visir.AgilentOscilloscope = function(id, elem, props)
{
	var me = this;
	visir.AgilentOscilloscope.parent.constructor.apply(this, arguments);
	this._measureCount = 0;

	var options = $.extend({
		MeasureCalling: function() {
			me._measureCount++;
			if (me._extService) me._extService.MakeMeasurement();
		}
		,CheckToContinueCalling: function() {
			//if (me._extService) return me._extService.CanContinueMeasuring();
			var maxMeasureCount = visir.Config.Get("maxOscMeasureCount");
			if (maxMeasureCount == undefined || maxMeasureCount == null) {
				maxMeasureCount = 10;
			}
 			if (me._measureCount >= maxMeasureCount)
				return false;

			return visir.Config.Get("oscRunnable") && me._canContinueMeasuring;
		}
	}, props || {});
	this._options = options;

	this._voltages = [5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01, 0.005, 0.002, 0.001];
	this._voltIdx = [2,2];

	this._timedivs = [0.005, 0.002, 0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001, 0.000005, 0.000002, 0.000001, 0.0000005];
	this._timeIdx = 1;

	this._triggerModes = ["autolevel", "auto", "normal"];
	this._triggerModesDisplay = ["Auto Level", "Auto", "Normal"];
	this._triggerModesLight = ["Level", "Auto", "Trig'd"];
	this._triggerModeIdx = 0;
	this._triggerLevelUnclamped = 0.0;

	var me = this;
	this._$elem = elem;

	// extend the channel information from base class with local per channel settings
	this._channels[0].visible = true;
	this._channels[0].display_offset = 0.0;
	this._channels[0].inverted = false;
	this._channels[1].visible = true;
	this._channels[1].display_offset = 0.0;
	this._channels[1].inverted = false;
	this._maindelayed = false;
	this._maindelayed_x = 0;
	this._maindelayed_y = 1;
	
	this._math = { visible: false, display_offset: 0.0, method: "sub", sourceCh: 0 };

	this._cursors = { visible: false, sourceCh: 0, p1: { x: 0.004, y: 0.002 }, p2: { x: -0.004, y: -0.002 }, selected: 0 };

	this._extService = null;
	this._canContinueMeasuring = false;

	this._menuPrev = null;
	this._menuTimer = null;


	$("body").on("working", function(e) {
		if (!e.isWorking) {
			me._canContinueMeasuring =  e.shouldContinue;
			if (!e.shouldContinue) {
				me._isMeasuringContinuous = false;
				me._UpdateRunStopSingleButtons("stopped");
			}
		}
	});

	function NewMeasInfo(display, str, unit, proto) {
		return { display: display, str: str, unit: unit, proto: proto };
	}

	this._measurementInfo = [
		NewMeasInfo("Amplitude", "Ampl", "V", "voltageamplitude")
		, NewMeasInfo("Average", "Avg", "V", "voltageaverage")
		, NewMeasInfo("Base", "Base", "V", "voltagebase")
		, NewMeasInfo("Duty Cycle", "Duty", "%", "negativedutycycle")
		, NewMeasInfo("Fall Time", "Fall", "s", "falltime")

		, NewMeasInfo("Frequency", "Freq", "Hz", "frequency")
		, NewMeasInfo("Maximum", "Max", "V", "voltagemax")
		, NewMeasInfo("Minimum", "Min", "V", "voltagemin")
		, NewMeasInfo("Overshoot", "Over", "%", "overshoot")
		, NewMeasInfo("Peak-Peak", "Pk-Pk", "V", "voltagepeaktopeak")

		, NewMeasInfo("Period", "Period", "s", "period")
		, NewMeasInfo("Phase", "Phase", "deg", "phasedelay")
		, NewMeasInfo("Preshoot", "Pre", "%", "preshoot")
		, NewMeasInfo("Rise Time", "Rise", "s", "risetime")
		, NewMeasInfo("RMS", "RMS", "V", "voltagerms")

		, NewMeasInfo("Top", "Top", "V", "voltagetop")
		, NewMeasInfo("+ Width", "+Width", "s", "positivewidth")
		, NewMeasInfo("- Width", "-Width", "s", "negativewidth")
	];

	this._measurementActiveCh = 1;
	this._measurementSelectionIdx = 0;
	this._measurementsVisible = false;

	this._activeMenu = ""; // the current menu displayed
	this._activeMenuHandler = null;

	this._activeIndicator = null;
	this._menuTitleTimer = null;

	//this._isMeasuring = false;
	this._isMeasuringContinuous = false;

	var imgbase = "instruments/ag_oscilloscope/images";
	if (visir.BaseLocation) imgbase = visir.BaseLocation + imgbase;

	var tplLocation = "instruments/ag_oscilloscope/ag_oscilloscope.tpl";
	if (visir.BaseLocation) tplLocation = visir.BaseLocation + tplLocation;

	if (visir.Config.Get("cacheBuster") != null) {
		tplLocation = tplLocation + "?cacheBuster=" + visir.Config.Get("cacheBuster");
	}

	// the placeholder is only used while loading, so that size computations are done right
	var $placeholder = $('<div class="ag_osc" />');
	elem.append($placeholder);

	$.get(tplLocation, function(tpl) {
		$placeholder.remove();
		tpl = tpl.replace(/%img%/g, imgbase);
		tpl = tpl.replace(/%downloadManual%/g, visir.Lang.GetMessage("down_man"));
		elem.append(tpl);

		if (typeof G_vmlCanvasManager !== "undefined")
		{
			G_vmlCanvasManager.initElement(elem.find(".grid"));
			G_vmlCanvasManager.initElement(elem.find(".plot"));
		}

		var unitstring_tpl = '<div class="large strings visible">V</div><div class="small strings"><div class="top">m</div><div class="bottom">v</div></div>';
		elem.find(".unitstring").append(unitstring_tpl);
		elem.find(".timescale .bottom").text("s");
		elem.find(".trig_delay .bottom").text("s");
		elem.find(".trig_delay .large").text("s");

		var prev = 0;

		function newHandleFunc(up, down)
		{
			up = up || function() {};
			down = down || function() {};
			return function(elem, deg, newTouch) {
				if (newTouch) { prev = deg; }
				var diff = deg - prev;
				// fixup the wrapping
				if (diff > 180) { diff = -360 + diff; }
				else if (diff < -180) { diff = 360 + diff; }

				if (Math.abs(diff) > 360/10) {
					prev = deg;
					if (diff < 0) { down(); }
					else if (diff > 0) { up(); }
					elem.find("img").toggleClass("active");
				}
				// dont return, we want it undefined
			};
		}

		if(!visir.Config.Get("readOnly"))
		{
			// abuses the turnable to get events, but not turning the component at all
			elem.find(".offset_ch1").turnable({turn: newHandleFunc(function() { me._StepDisplayOffset(0, true); }, function() { me._StepDisplayOffset(0, false); }) });
			elem.find(".offset_ch2").turnable({turn: newHandleFunc(function() { me._StepDisplayOffset(1, true); }, function() { me._StepDisplayOffset(1, false); }) });

			elem.find(".offset_trg").turnable({turn: newHandleFunc(function() { me._StepTriggerLevel(true); }, function() { me._StepTriggerLevel(false); }) });
			elem.find(".horz").turnable({turn: newHandleFunc(function() { me._SetTimedivIdx(me._timeIdx+1); }, function() { me._SetTimedivIdx(me._timeIdx-1); }) });
			elem.find(".horz_offset").turnable({turn: newHandleFunc(function() { me._StepTriggerDelay(true); }, function() { me._StepTriggerDelay(false); }) });
			elem.find(".selection_knob").turnable({turn: newHandleFunc(function() { me._StepSelection(true); }, function() { me._StepSelection(false); }) });
			elem.find(".vert_ch1").turnable({turn: newHandleFunc(function() { me._SetVoltIdx(0, me._voltIdx[0]+1); }, function() { me._SetVoltIdx(0, me._voltIdx[0]-1);}) });
			elem.find(".vert_ch2").turnable({turn: newHandleFunc(function() { me._SetVoltIdx(1, me._voltIdx[1]+1); }, function() { me._SetVoltIdx(1, me._voltIdx[1]-1);}) });

			elem.find(".button").updownButton();
			elem.find(".channel_1").click( function() {
				// XXX: only toggle if its the active selection.. but we have no menus right now
				me._ToggleChEnabled(0);
			});
			elem.find(".channel_2").click( function() {
				// XXX: only toggle if its the active selection.. but we have no menus right now
				me._ToggleChEnabled(1);
			});

			elem.find(".button.maindelayed").click( function() {
				me._ShowMenu("menu_main_delayed");
			});
			
			elem.find(".button.edge").click( function() {
				// light up the edge button
				me._$elem.find(".multibutton.edge .state").removeClass("visible");
				me._$elem.find(".multibutton.edge .state.light").addClass("visible");

				me._ShowMenu("menu_edge");
			});

			elem.find(".button.cursors").click( function() {
				me._ToggleCursors();
			});

			elem.find(".button.measure").click( function() {
				me._ToggleMeasurements();
			});

			elem.find(".button.modecoupling").click( function() {
				me._ShowMenu("menu_modecoupling");
			});

			elem.find(".button.saverecall").click( function() {
				me._SaveWaveform();
			});			

			elem.find(".button.math").click( function() {
				me._ToggleMathEnabled();
			});

			elem.find(".button.single").click( function() {
				me._MakeMeasurement("single");
			});
			elem.find(".button.runstop").click( function() {
				me._MakeMeasurement("runstop");
			});

			elem.find(".display_button_1").click( function() { me._DisplayButtonClicked(1); });
			elem.find(".display_button_2").click( function() { me._DisplayButtonClicked(2); });
			elem.find(".display_button_3").click( function() { me._DisplayButtonClicked(3); });
			elem.find(".display_button_4").click( function() { me._DisplayButtonClicked(4); });
			elem.find(".display_button_5").click( function() { me._DisplayButtonClicked(5); });
			elem.find(".display_button_6").click( function() { me._DisplayButtonClicked(6); });
		}

		elem.find(".infobar .box").hide();

		me._plotWidth = me._$elem.find(".graph").width();
		me._plotHeight = me._$elem.find(".graph").height();

		me._DrawGrid(elem.find(".grid"));
		me._DrawPlot(elem.find(".plot"));
		me._UpdateChannelDisplay(0);
		me._UpdateChannelDisplay(1);
		me._UpdateDisplay();

		me._menuHandlers = {
			'menu_channel_1': CreateChannelMenu(me, 0, me._$elem.find(".menu_channel_1"))
			, 'menu_channel_2': CreateChannelMenu(me, 1, me._$elem.find(".menu_channel_2"))
			, 'menu_main_delayed': CreateMainDelayedMenu(me, me._$elem.find(".menu_main_delayed"))
			, 'menu_edge': CreateEdgeMenu(me, me._$elem.find(".menu_edge"))
			, 'menu_modecoupling': CreateTriggerModeCouplingMenu(me, me._$elem.find(".menu_modecoupling"))
			, 'menu_measure': CreateMeasurementMenu(me, me._$elem.find(".menu_measure"))
			, 'menu_cursors': CreateCursorsMenu(me, me._$elem.find(".menu_cursors"))
			, 'menu_math': CreateMathMenu(me, me._$elem.find(".menu_math"))
		};

		me._UpdateRunStopSingleButtons("stopped");

		me._ShowCursors(false);

		if (visir.Config.Get("displayManuals") == false) {
			elem.find(".manual_link").remove();
		}
	});
};

extend(visir.AgilentOscilloscope, visir.Oscilloscope);

visir.AgilentOscilloscope.prototype._DrawGrid = function($elem)
{
	var context = $elem[0].getContext('2d');

	//context.strokeStyle = "#004000";
	context.strokeStyle = "#00ff00";
	context.lineWidth		= 0.5;
	context.beginPath();

	var len = 3.5;
	/* Get the size from the .graph element instead.
		This works around the problem where canvases get no size if a parent node has display:none.
	*/
	var w = $elem.parent().width();
	var h = $elem.parent().height()

	var xspacing = w / 10;
	var yspacing = h / 8;
	var i, x, y;

	for(i=1;i<=9;i++) {
		x = xspacing * i;
		x += 0.5;
		context.moveTo(x, 0);
		context.lineTo(x, h);
	}

	for(i=1;i<=10*5 ;i++) {
		if (i % 5 === 0) { continue; }
		x = (xspacing / 5) * i;
		x += 0.5;
		var h2 = (h / 2) + 0.5;
		context.moveTo(x, h2 - len);
		context.lineTo(x, h2 + len);
	}

	for(i=1;i<=7;i++) {
		y = yspacing * i;
		context.moveTo(0, y+0.5);
		context.lineTo(w, y+0.5);
	}

	for(i=1;i<=7*5 ;i++) {
		if (i % 4 === 0) { continue; }
		y = (yspacing / 4) * i;
		y += 0.5;
		var w2 = (w / 2);
		w2 = Math.floor(w2) + 0.5;
		context.moveTo(w2 - len, y);
		context.lineTo(w2 + len, y);
	}

	context.stroke();
};

visir.AgilentOscilloscope.prototype._DrawPlot = function($elem)
{
	if ($elem.length == 0) {
		return;
	}
	var context = $elem[0].getContext('2d');
	context.strokeStyle = "#00ff00";
	context.lineWidth		= 1.2;

	/* Get the size from the .graph element instead.
		This works around the problem where canvases get no size if a parent node has display:none.
	*/
	var w = $elem.parent().width();
	var h = $elem.parent().height();
	context.clearRect(0,0, w, h);
	context.beginPath();

	var me = this;
	// local draw function
	function DrawChannel(chnr) {
		if (!me._channels[chnr].visible) { return; }
		var ch = me._channels[chnr];
		var graph = ch.graph;
		var len = graph.length;
		for(var i=0;i<len;i++) {
			var x = i*w / len;
			var y = -((graph[i] * (me._channels[chnr].inverted ? -1 : 1) / ch.range) + ch.display_offset) * (h / 8.0) + h/2;
			y+=0.5;
			if (i===0) {
				context.moveTo(x,y);
			} else {
				context.lineTo(x,y);
			}
		}
	}

	function DrawXY(chnr1, chnr2) {
		if (!me._maindelayed) { return; }
		var maxrange = Math.max(me._channels[0].range, me._channels[1].range);
		var ch1 = me._channels[0];
		var ch2 = me._channels[1];
		var graph1 = ch1.graph;
		var graph2 = ch2.graph;
		var len = Math.min(graph1.length, graph2.length);
		var sum = 0.0;
		for(var i=0;i<len;i++) {
			var samplex;
			var sampley;
			var rangex;
			var rangey;
			var offsetx;
			var offsety;
			var range1 = ch1.range;
			var range2 = ch2.range;
			var offset1 = ch1.display_offset;
			var offset2 = ch2.display_offset;
			var sample = 0.0;
			var sample1 = graph1[i] * (ch1.inverted ? -1 : 1);
			var sample2 = graph2[i] * (ch2.inverted ? -1 : 1);
			var	samplem = graph1[i] * (ch1.inverted ? -1 : 1) - graph2[i] * (ch2.inverted ? -1 : 1);
			var	rangem = maxrange;
			var	offsetm = me._math.display_offset;
			switch(chnr1) {
				case 0:
					samplex = sample1;
					offsetx = offset1;
					rangex = range1;
					break;
				case 1:
					samplex = sample2;
					offsetx = offset2;
					rangex = range2;
					break;
				case 2:
					samplex = samplem;
					offsetx = offsetm;
					rangex = rangem;
					break;
			}
			switch(chnr2) {
				case 0:
					sampley = sample1;
					offsety = offset1;
					rangey = range1;
					break;
				case 1:
					sampley = sample2;
					offsety = offset2;
					rangey = range2;
					break;
				case 2:
					sampley = samplem;
					offsety = offsetm;
					rangey = rangem;
					break;
			}
						
			var x = ((samplex / rangex) + offsetx) * (w / 8.0) + w/2;
			var y = -((sampley / rangey) + offsety) * (h / 8.0) + h/2;
			y += 0.5;
			if (i===0) {
				context.moveTo(x,y);
			} else {
				context.lineTo(x,y);
			}
		}
	}

	function DrawMath() {
		if (!me._math.visible) return;
		var maxrange = Math.max(me._channels[0].range, me._channels[1].range);
		var graph1 = me._channels[0].graph;
		var graph2 = me._channels[1].graph;
		var len = Math.min(graph1.length, graph2.length);
		var sum = 0.0;
		for(var i=0;i<len;i++) {
			var sample = 0.0;
			var sample1 = graph1[i] * (me._channels[0].inverted ? -1 : 1);
		 	var sample2 = graph2[i] * (me._channels[1].inverted ? -1 : 1);
			switch(me._math.method) {
				case "sub":
					sample = sample1 - sample2;
					break;
				case "mul":
					sample = sample1 * sample2;
					break;
				case "derive":
					var g = me._channels[me._math.sourceCh].graph;
					sample = (i == 0) ? 0 : g[i] - g[i-1];
					break;
				case "integrate":
					var g = me._channels[me._math.sourceCh].graph;
					//sum = sum + (i == 0) ? 0 : (g[i] + g[i-1]) / 2.0;
					sum = sum + (g[i] / 4) ;
					sample = sum;
					break;
			}

			var x = i*w / len;
			var y = -((sample / maxrange) + me._math.display_offset) * (h / 8.0) + h/2;
			y+=0.5;
			if (i===0) {
				context.moveTo(x,y);
			} else {
				context.lineTo(x,y);
			}
		}
	}

	function transformX(x)
	{
		var timediv = me._timedivs[me._timeIdx];
		return (w / 2.0) + x / timediv * (w/10.0);
	}

	function transformY(ch, y)
	{
			return -((y * (ch.inverted ? -1 : 1) / ch.range) + ch.display_offset) * (h / 8.0) + h/2;
	}

	function DrawCursors()
	{
		function DrawCursor(x1, y1, x2, y2, color, dash) {
			if (typeof context.setLineDash == "function") context.setLineDash(dash);
			context.save(); 
			context.strokeStyle = color;
			context.beginPath();
			context.moveTo(x1+0.5, y1+0.5);
			context.lineTo(x2+0.5, y2+0.5);
			context.stroke();
			context.restore();
			if (typeof context.setLineDash == "function") context.setLineDash([0]);
		}

		var ch = me._channels[me._cursors.sourceCh];

		if (!me._cursors.visible) return;
		var selcolor = "#ffff00";
		var unselcolor = "#00ffff";
		DrawCursor(transformX(me._cursors.p1.x), 0, transformX(me._cursors.p1.x), h, me._cursors.selected & 1 ? selcolor : unselcolor, [4]);
		DrawCursor(transformX(me._cursors.p2.x), 0, transformX(me._cursors.p2.x), h, me._cursors.selected & 2 ? selcolor : unselcolor, [5]);
		DrawCursor(0, transformY(ch, me._cursors.p1.y), w, transformY(ch, me._cursors.p1.y), me._cursors.selected & 4 ? selcolor : unselcolor, [6]);
		DrawCursor(0, transformY(ch, me._cursors.p2.y), w, transformY(ch, me._cursors.p2.y), me._cursors.selected & 8 ? selcolor : unselcolor, [7]);
	}
	if (!me._maindelayed) {
		DrawChannel(0);
		DrawChannel(1);
		context.stroke();
		DrawCursors();

		context.strokeStyle = "#ff0000";
		context.beginPath();
		DrawMath();
		context.stroke();
	} else {
		context.strokeStyle = "#ffff00";
		context.beginPath();
		DrawXY(me._maindelayed_x,me._maindelayed_y);
		context.stroke();
	}
};

visir.AgilentOscilloscope.prototype._SetVoltIdx = function(ch, idx)
{
	if (idx < 0) { idx = 0; }
	if (idx > this._voltages.length - 1) { idx = this._voltages.length - 1; }
	this._voltIdx[ch] = idx;

	// sets value for serialization
	this._channels[ch].range = this._voltages[idx];
	this._channels[ch].offset = this._voltages[idx] * -this._channels[ch].display_offset;

	var indicatorName = (ch === 0 ? ".voltage_ch1" : ".voltage_ch2");
	var $indicator = this._$elem.find(indicatorName);
	this._LightIndicator($indicator);
	this._UpdateTriggerLevel();
	this._UpdateDisplay();
};

visir.AgilentOscilloscope.prototype._SetTimedivIdx = function(idx)
{
	if (idx < 0) { idx = 0; }
	if (idx > this._timedivs.length - 1) { idx = this._timedivs.length - 1; }
	this._timeIdx = idx;
	this._sampleRate = 1.0 / this._timedivs[this._timeIdx]; // sets value for serialization

	var $indicator = this._$elem.find(".timediv");
	this._LightIndicator($indicator);
	this._UpdateTriggerDelay();
	this._UpdateDisplay();
};

visir.AgilentOscilloscope.prototype._StepDisplayOffset = function(ch, up)
{
	var stepsize = 0.05;
	var val = this._channels[ch].display_offset + (up ? stepsize : -stepsize);
	this._SetDisplayOffset(ch, val);
};

visir.AgilentOscilloscope.prototype._SetDisplayOffset = function(ch, offset)
{
	var stepsize = 0.05;
	offset = Math.round(offset / stepsize) * stepsize;
	this._channels[ch].display_offset = offset;

	// set values for serialization
	this._channels[ch].offset = this._voltages[this._voltIdx[ch]] * -this._channels[ch].display_offset;

	// move and update offset indicators
	var $group = this._$elem.find(".display .vertical " + (ch === 0 ? ".offset_group_ch1" : ".offset_group_ch2"));
	$group.find(".ch_offset").removeClass("visible");
	if (offset >= 4) { // show overflow indicator
		$group.find(".overflow_up").addClass("visible");
	} else if (offset <= -4) { // show underflow indicator
		$group.find(".overflow_down").addClass("visible");
	} else { // show normal indicator and move it into position
		var $indicator = $group.find(".normal");
		var h = this._plotHeight;
		var top = -offset * (h / 8.0) + h/2;
		$indicator.addClass("visible");
		$indicator.css("top", top + "px");
	}

	this._UpdateTriggerLevel();
	this._UpdateDisplay();
};

/*
	The trigger level should stay the same until its steped
	When changing the voltdiv the result should be clamped and displayed correctly, but when changing back, the level should change back as well.
*/

// Takes the unclamped value as basis, steps and sets a new value based on that.
visir.AgilentOscilloscope.prototype._StepTriggerLevel = function(up)
{
	// side effect, if trigger mode is auto level, set to auto
	if (this._triggerModeIdx === 0) {
		this._SetTriggerMode(1);
	}

	var level = this._ClampTriggerLevel(this._triggerLevelUnclamped);

	var trigch = this._channels[this._trigger.source - 1];
	var stepsize = trigch.range / 10;
	var newval = level + (up ? stepsize : -stepsize);
	this._triggerLevelUnclamped = newval;

	this._SetTriggerLevel(newval, true);
};

// clamps the trigger level, sets up the serialized data and updates the display
visir.AgilentOscilloscope.prototype._SetTriggerLevel = function(level, showLight)
{
	showLight = showLight || false;
	level = this._ClampTriggerLevel(level);

	this._trigger.level = level;

	var $indicator = this._$elem.find(".triglevel .lighttext");
	//this._$elem.find(".triglevel .lighttext").text(this._FormatValue(level) + "V");
	this._LightIndicator($indicator);
	this._UpdateTriggerLevel();
};

visir.AgilentOscilloscope.prototype._ClampTriggerLevel = function(level)
{
	var trigch = this._channels[this._trigger.source - 1];
	var stepsize = trigch.range / 10;
	level = Math.round(level / stepsize) * stepsize;
	var max = -trigch.offset + (6*trigch.range);
	var min = -trigch.offset - (6*trigch.range);
	if (level > max) { level = max; }
	if (level < min) { level = min; }
	return level;
};

visir.AgilentOscilloscope.prototype._UpdateTriggerLevel = function()
{
	var trigch = this._channels[this._trigger.source - 1];
	var level = this._ClampTriggerLevel(this._triggerLevelUnclamped);
	this._trigger.level = level; // XXX: updating the serialized value here is not optimal..

	//trace("update trigger level: " + (this._trigger.source - 1) + " " + level);

	var markerPos = (((-level + trigch.offset) / trigch.range) ) * (this._plotHeight / 8.0) + (this._plotHeight / 2.0);
	markerPos = Math.round(markerPos);

	var $group = this._$elem.find(".display .vertical .group.trigger_group");
	$group.find(".ch_offset").removeClass("visible");

	if (markerPos <= 0) { // show overflow indicator
		$group.find(".overflow_up").addClass("visible");
	} else if (markerPos >= this._plotHeight) { // show underflow indicator
		$group.find(".overflow_down").addClass("visible");
	} else { // show normal indicator and move it into position
		var $indicator = $group.find(".normal");
		$indicator.addClass("visible");
		$indicator.css("top", markerPos + "px");
	}

	this._SetIndicatorValue(this._$elem.find(".triglevel .lighttext"), level);
	//SetText(this._$elem.find(".triglevel .lighttext"), this._FormatValue(level));
	//this._$elem.find(".triglevel .lighttext").text(this._FormatValue(level));
};

/* Trigger delay */

visir.AgilentOscilloscope.prototype._ClampTriggerDelay = function(val)
{
	var timediv = this._timedivs[this._timeIdx];
	var stepsize = timediv / 10;
	val = Math.round(val / stepsize) * stepsize;
	var max = timediv * 10; //-trigch.offset + (6*trigch.range);
	var min = 0; //-trigch.offset - (6*trigch.range);
	if (val > max) { val = max; }
	if (val < min) { val = min; }
	return val;
}

visir.AgilentOscilloscope.prototype._StepTriggerDelay = function(up)
{	
	var timediv = this._timedivs[this._timeIdx];
	var stepsize = timediv / 10;
	var val = this._trigger.delay + (up ? -stepsize : stepsize);
	val = this._ClampTriggerDelay(val);
	this._trigger.delay = val;
	
	var $indicator = this._$elem.find(".trig_delay");
	this._LightIndicator($indicator);
	
	this._UpdateTriggerDelay();
	this._UpdateDisplay();
	
	//trace("_StepTriggerDelay: " + val);
}

visir.AgilentOscilloscope.prototype._UpdateTriggerDelay = function()
{
	trace("_UpdateTriggerDelay");
	var timediv = this._timedivs[this._timeIdx];
	var markerPos = ((-this._trigger.delay / timediv) ) * (this._plotWidth / 10.0) + (this._plotWidth / 2.0) - 3;
	markerPos = Math.round(markerPos);
	this._$elem.find(".timedelay_markers .marker").css("left", markerPos + "px");
	//trace("mX: " + markerPos);
}

/* */

// XXX: maybe rename to ChButtonPressed or something..
visir.AgilentOscilloscope.prototype._ToggleChEnabled = function(ch)
{
	var showMenu = "menu_channel_" + (ch+1);
	var visibile = this._activeMenu !== showMenu || !this._channels[ch].visible;
	this._ShowMenu(showMenu);
	this._SetChEnabled(ch, visibile);
};

visir.AgilentOscilloscope.prototype._ToggleMathEnabled = function()
{
	var visible = this._activeMenu !== "menu_math" || !this._math.visible;
	this._ShowMenu("menu_math");
	this._math.visible = visible;
	this._SetLightButtonState(this._$elem.find(".multibutton.math"), visible);
	this._UpdateDisplay();
}

visir.AgilentOscilloscope.prototype._ToggleChCoupling = function(ch)
{
	this._channels[ch].coupling = (this._channels[ch].coupling === "dc") ? "ac" : "dc";
};

visir.AgilentOscilloscope.prototype._SetChEnabled = function(ch, enabled)
{
	this._channels[ch].visible = enabled;
	this._UpdateChannelDisplay(ch);
	this._UpdateDisplay();
};

visir.AgilentOscilloscope.prototype._SetTriggerSlope = function(slope)
{
	this._trigger.slope = slope;
	this._$elem.find(".display .triggerslope .flank.selected").removeClass("selected");
	this._$elem.find(".display .triggerslope .flank." +slope).addClass("selected");
};

visir.AgilentOscilloscope.prototype._SetTriggerSource = function(ch)
{
	this._trigger.source = ch;
	this._$elem.find(".display .triggersource .channelname").text(ch);
	this._UpdateTriggerLevel();
};

visir.AgilentOscilloscope.prototype._SetTriggerMode = function(modeIdx)
{
	if (modeIdx < 0 || modeIdx >= this._triggerModes.length) {
		throw "invalid trigger mode index";
	}
	this._triggerModeIdx = modeIdx;
	this._trigger.mode = this._triggerModes[modeIdx];

	this._$elem.find(".lighttext.triggermode").text(this._triggerModesLight[modeIdx]);
	this._$elem.find(".menu_modecoupling .value.mode").text(this._triggerModesDisplay[this._triggerModeIdx]); // need to update the menu (if its active)
};

visir.AgilentOscilloscope.prototype._IsMeasurementEnabled = function()
{
}

visir.AgilentOscilloscope.prototype._ToggleMeasurements = function()
{
	var enabled = this._IsMeasurementEnabled();
	// if ( measurement mode is selected) {
	enabled = !enabled;
	// }
	this._ShowMenu("menu_measure");
}

visir.AgilentOscilloscope.prototype._AddMeasurementAndAnimate = function(ch, selection)
{
	// update protocol info
	var full = this._measurements.length == 3;
	var replaced = this.AddMeasurement(ch, this._measurementInfo[this._measurementSelectionIdx].proto, selection);
	var $infobar = this._$elem.find(".infobar");
	var $box1 = $infobar.find(".box1");
	var $box2 = $infobar.find(".box2");
	var $box3 = $infobar.find(".box3");

	var pos = [ 0, 110, 220];
	var fast = 250;
	var slowanim = { left: "-=110" };
	var fastanim = { left: "-=250" };

	trace("replaced: " + replaced);

	if (replaced >= 0) {
		// move first box back to second and animate back to first
		if (replaced < 1) { $box1.stop().css("left", pos[1] + "px").animate(slowanim); }
		// move second to third and animate to second
		if (replaced < 2) { $box2.stop().css("left", pos[2] + "px").animate(slowanim); }
	} else if (full) {
		// if the container is full and none were replaced, move the first and second
		$box1.show().stop().css("left", pos[1] + "px").animate(slowanim);
		$box2.show().stop().css("left", pos[2] + "px").animate(slowanim);
	}

	$box1.text("(" + this._measurements[0].channel + ") " + this._measurementInfo[this._measurements[0].extra].str + ":");
	if (this._measurements.length > 1) $box2.text("(" + this._measurements[1].channel + ") " + this._measurementInfo[this._measurements[1].extra].str + ":");
	if (this._measurements.length > 2) $box3.text("(" + this._measurements[2].channel + ") " + this._measurementInfo[this._measurements[2].extra].str + ":");

	// move in the last item with greater speed
	if (this._measurements.length == 1) { $box1.show().stop().css("left", pos[0] + fast + "px").animate(fastanim); }
	if (this._measurements.length == 2) { $box2.show().stop().css("left", pos[1] + fast + "px").animate(fastanim); }
	if (this._measurements.length == 3) { $box3.show().stop().css("left", pos[2] + fast + "px").animate(fastanim); }
}

visir.AgilentOscilloscope.prototype._ClearMeasurement = function()
{
	this._$elem.find(".infobar .box").hide();
	this._measurements = [];
}

visir.AgilentOscilloscope.prototype._StepSelection = function(up)
{
	if (this._activeMenu == "menu_measure") {
		this._measurementSelectionIdx = (up) ? this._measurementSelectionIdx + 1 : this._measurementSelectionIdx - 1;
		if (this._measurementSelectionIdx < 0) this._measurementSelectionIdx = this._measurementInfo.length - 1;
		if (this._measurementSelectionIdx >= this._measurementInfo.length) this._measurementSelectionIdx = 0;
		this._activeMenuHandler.ShowMenu("sel_meas_selection");
	}
}

visir.AgilentOscilloscope.prototype._ShowMenu = function(menuname)
{
	var $menu = this._$elem.find(".menu." + menuname);
	if ($menu.length === 0) {
		throw "unable to find menu: " + menuname;
	}
	this._$elem.find(".display .menubar .menu").removeClass("visible");
	$menu.addClass("visible");

	this._activeMenu = menuname;
	this._activeMenuHandler = this._menuHandlers[menuname];
	var name = this._activeMenuHandler.GetName();
	this._$elem.find(".display .menubar .menutitle .titlebox").text(name);
	this._$elem.find(".display .menubar .menutitle").addClass("visible");

	if (this._menuTitleTimer) {
		clearTimeout(this._menuTitleTimer);
	}
	var me = this;
	this._menuTitleTimer = setTimeout( function() { me._$elem.find(".display .menubar .menutitle").removeClass("visible"); this._menuTitleTimer = null; }, 1000);
};

visir.AgilentOscilloscope.prototype._DisplayButtonClicked = function(button)
{
	if (this._activeMenuHandler && this._activeMenuHandler.ButtonPressed) {
		this._activeMenuHandler.ButtonPressed(button);
	}
};

visir.AgilentOscilloscope.prototype._GetUnit = function(val)
{
	var units = [
		["M", 6 ]
		, ["K", 3 ]
		, ["", 0]
		, ["m", -3]
		, ["u", -6]
		, ["n", -9]
		];
	val = Math.abs(val);
	if (val === 0) {
		return { unit: "", pow: 0 };
	}

	for (var key in units) {
		var unit = units[key];
		if (val >= Math.pow(10, unit[1])) {
			return {unit: unit[0], pow: unit[1] };
		}
	}

	var last = units[units.length - 1];
	return {unit: last[0], pow: last[1] };
};

// takes care of updating the light indicator value and sets the unit string correctly if present
visir.AgilentOscilloscope.prototype._SetIndicatorValue = function($elem, value)
{
	var unit = this._GetUnit(value);
	value /= Math.pow(10,unit.pow);
	var str = value.toPrecision(3);

	$elem.find(".strings").removeClass("visible");
	$elem.find((unit.unit === "") ? ".large" : ".small").addClass("visible");
	$elem.find(".top").text(unit.unit);
	$elem.find(".value").text(this._FormatValue(str));
	//SetText($elem, this._FormatValue(str));
};

visir.AgilentOscilloscope.prototype._LightIndicator = function($elem)
{
	if (this._activeIndicator && this._activeIndicator.Destroy) {
		this._activeIndicator.Destroy();
		this._activeIndicator = null;
	}

	var me = this;
	$elem.addClass("light");
	var timer = setTimeout(function() {
		me._activeIndicator.Destroy();
		me._activeIndicator = null;
	}, 2000);

	this._activeIndicator = {
		Destroy: function() { $elem.removeClass("light"); clearInterval(timer); }
	};
};

visir.AgilentOscilloscope.prototype._FormatValue = function(val)
{
	var unit = this._GetUnit(val);
	val /= Math.pow(10,unit.pow);
	return val.toPrecision(3) + unit.unit;
};

visir.AgilentOscilloscope.prototype._SetLightButtonState = function($btn, lightOn)
{
	$btn.find(".state").removeClass("visible");
	if (lightOn) {
		$btn.find(".light").addClass("visible");
	} else {
		$btn.find(".dark").addClass("visible");
	}
}

// this should be called when the channel properties have changed
// currently: visible is tracked
visir.AgilentOscilloscope.prototype._UpdateChannelDisplay = function(ch)
{
		var css_ch_name = ".channel." + (ch===0 ? "ch1" : "ch2");
		var css_group_name = ".display .vertical .offset_group_" + (ch===0 ? "ch1" : "ch2");
		var css_button_name = ".multibutton.channel_" + (ch+1);
		if (this._channels[ch].visible) {
			this._$elem.find(css_ch_name).addClass("visible");
			this._$elem.find(css_group_name).addClass("visible");
			this._$elem.find(css_button_name).find(".state").removeClass("visible");
			this._$elem.find(css_button_name).find(".light").addClass("visible");
		} else {
			this._$elem.find(css_ch_name).removeClass("visible");
			this._$elem.find(css_group_name).removeClass("visible");
			this._$elem.find(css_button_name).find(".state").removeClass("visible");
			this._$elem.find(css_button_name).find(".dark").addClass("visible");
		}
};

visir.AgilentOscilloscope.prototype._UpdateDisplay = function()
{
	this._SetIndicatorValue(this._$elem.find(".voltage_ch1"), this._voltages[this._voltIdx[0]]);
	this._SetIndicatorValue(this._$elem.find(".voltage_ch2"), this._voltages[this._voltIdx[1]]);
	this._SetIndicatorValue(this._$elem.find(".timediv"), this._timedivs[this._timeIdx]);
	this._SetIndicatorValue(this._$elem.find(".topbar .trig_delay"), this._trigger.delay);
	//this._$elem.find(".voltage_ch1").text(this._FormatValue(this._voltages[this._voltIdx[0]]) + "V");
	//this._$elem.find(".voltage_ch2").text(this._FormatValue(this._voltages[this._voltIdx[1]]) + "V");
	//this._$elem.find(".timediv").text(this._FormatValue(this._timedivs[this._timeIdx]) + "s");

	this._DrawPlot(this._$elem.find(".plot"));
};

visir.AgilentOscilloscope.prototype._ToggleCursors = function()
{

}

visir.AgilentOscilloscope.prototype._ShowCursors = function(show)
{
	this._$elem.find(".graph .cursors").toggle(show);

	var $infobar = this._$elem.find(".infobar");
	var $box1 = $infobar.find(".box1");
	var $box2 = $infobar.find(".box2");
	var $box3 = $infobar.find(".box3");
	$box1.toggle(show);
	$box2.toggle(show);
	$box3.toggle(show);
}

visir.AgilentOscilloscope.prototype.ReadResponse = function(response) {
	var me = this;
	visir.AgilentOscilloscope.parent.ReadResponse.apply(this, arguments);
	this._DrawPlot(this._$elem.find(".plot"));

	// check if we should continue measuring
	if (this._isMeasuringContinuous && this._options.CheckToContinueCalling()) {
		this._options.MeasureCalling();
	} else {
		this._isMeasuringContinuous = false;
		this._$elem.find(".button.runstop .state").removeClass("visible");
		this._$elem.find(".button.runstop .state.red").addClass("visible");
		this._$elem.find(".button.single .state").removeClass("visible");
		this._$elem.find(".button.single .state.dark").addClass("visible");
	}

	function UpdateResult($elem, measurement) {
		var str = "(" + measurement.channel + ") " + me._measurementInfo[measurement.extra].str + ": ";
		var unit = visir.GetUnit(measurement.result);
		str += (measurement.result / Math.pow(10, unit.pow)).toPrecision(4);
		str += unit.unit;
		str += me._measurementInfo[measurement.extra].unit;
		$elem.text(str);
	}

	var $measurements = this._$elem.find(".measurements");
	if (this._measurements.length > 0) UpdateResult($measurements.find(".box1"), this._measurements[0]);
	if (this._measurements.length > 1) UpdateResult($measurements.find(".box2"), this._measurements[1]);
	if (this._measurements.length > 2) UpdateResult($measurements.find(".box3"), this._measurements[2]);
};

visir.AgilentOscilloscope.prototype._UpdateRunStopSingleButtons = function(state)
{
	switch(state) {
		case "single":
			this._$elem.find(".button.runstop .state").removeClass("visible");
			this._$elem.find(".button.runstop .state.dark").addClass("visible");
			this._$elem.find(".button.single .state").removeClass("visible");
			this._$elem.find(".button.single .state.light").addClass("visible");
		break;

		case "run":
			this._$elem.find(".button.single .state").removeClass("visible");
			this._$elem.find(".button.single .state.dark").addClass("visible");
			this._$elem.find(".button.runstop .state").removeClass("visible");
			this._$elem.find(".button.runstop .state.green").addClass("visible");
		break;

		case "stopped":
		default:
			this._$elem.find(".button.runstop .state").removeClass("visible");
			this._$elem.find(".button.runstop .state.red").addClass("visible");
			this._$elem.find(".button.single .state").removeClass("visible");
			this._$elem.find(".button.single .state.dark").addClass("visible");
		break;
	}
}

visir.AgilentOscilloscope.prototype._MakeMeasurement = function(button) {
	this._measureCount = 0;
	switch(button) {
		case "single":
			this._UpdateRunStopSingleButtons("single");
			this._isMeasuringContinuous = false;
			this._options.MeasureCalling();

		break;
		case "runstop":
			this._UpdateRunStopSingleButtons("run");
			if ( ! visir.Config.Get("oscRunnable") || this._isMeasuringContinuous) {
				this._isMeasuringContinuous = false;
				this._UpdateRunStopSingleButtons("stopped");

				if ( ! visir.Config.Get("oscRunnable"))
					alert(visir.Lang.GetMessage("osc_not_runnable"));
			} else {
				this._isMeasuringContinuous = true;
				this._options.MeasureCalling();
			}
		break;
	}
};

visir.AgilentOscilloscope.prototype.UseExteralService = function(service) {
	trace("AgilentOscilloscope::UseExteralService");
	this._extService = service;
}

visir.AgilentOscilloscope.prototype._HideMenuAfter = function(menu, unique, duration_ms) {
	duration_ms = duration_ms || 1000;
	unique = unique || 1;

	//var same = menu === this._menuPrev;

	var me = this;
	var hideFunc = function() { menu.HideMenu(unique); me._menuPrev = null; trace("---------- hiding ---------");}

	var same = (!!this._menuPrev) && (this._menuPrev.menu === menu) && (this._menuPrev.unique == unique);
	trace("prevmenu: " + this._menuPrev);

	if (!same && this._menuPrev) {
		trace("hiding previous");
		this._menuPrev.hideFunc();
	}

	if (this._menuTimer) {
		trace("clear timer");
		clearTimeout(this._menuTimer);
	}
	
	this._menuTimer = setTimeout(hideFunc, duration_ms); 
	this._menuPrev = { menu: menu, unique: unique, hideFunc: hideFunc };

	trace("same: " + same);
	return same;
}

visir.AgilentOscilloscope.prototype._SaveWaveform = function() {
	trace("Saving waveform to csv");

	if (navigator.userAgent.match(/iPhone|iPad|Android/)) {
		trace("Save not supported on handheld devices");
		return;
	}

	var out = '';
	out += 'sep=\t\r\n';
	out += 'Time\tChannel1\tChannel2\r\n';

	var ch1 = this._channels[0].graph;
	var ch2 = this._channels[1].graph;
	var dtime1 = this._timedivs[this._timeIdx] * 10.0 / this._channels[0].graph.length;
	for(var i=0;i<ch1.length;i++) {
		var t1 = (i - (ch1.length / 2)) * dtime1;
		out += t1 + "\t" + ch1[i] + "\t" + ch2[i] + "\r\n";
	}

	var blob = new Blob([out], {type: "text/csv;charset=UTF-8"});
	saveAs(blob, "waveform.csv");
}

/* Menus */

function CreateChannelMenu(osc, ch, $menu)
{
	var timer = null;
	return {
		GetName: function() { this.Redraw(); return "Channel " + (ch+1) + " Menu"; },
		ButtonPressed: function(nr) {
			switch(nr) {
				case 1:
					if (!this.ShowMenu()) return;
					osc._ToggleChCoupling(ch);
					this.Redraw();
				break;
				case 2:
					osc._channels[ch].inverted = !osc._channels[ch].inverted;
					this.Redraw();
					osc._UpdateDisplay();
					break;
				case 3:
					if (ch == 1) {
						osc._channels[ch].xyg = !osc._channels[ch].xyg;
						this.Redraw();
						osc._UpdateDisplay();
					}
				default:
				break;
			}

		},
		Redraw: function() {
			var coupling = osc._channels[ch].coupling;
			$menu.find(".value.coupling").text(coupling.toUpperCase());
			$menu.find(".selection").removeClass("selected");
			$menu.find(".selection.sel_" + coupling).addClass("selected");
			$menu.find(".checkbox.invert").removeClass("selected");
			$menu.find(".checkbox.xyg").removeClass("selected");
			if(osc._channels[ch].inverted) {
				$menu.find(".checkbox.invert").addClass("selected");
			}
			if(osc._channels[ch].xyg) {
				$menu.find(".checkbox.xyg").addClass("selected");
			}
		},
		ShowMenu: function() {
			$menu.find(".menu_selection.sel_ch_" + (ch+1)).addClass("visible");
			return osc._HideMenuAfter(this);
		},
		HideMenu: function() {
			$menu.find(".menu_selection.sel_ch_" + (ch+1)).removeClass("visible");
		}
	};
}

function CreateMainDelayedMenu(osc, $menu)
{
	var timer = null;
	if (osc._maindelayed) {
		$(".menubox.mainx").show();
		$(".menubox.mainy").show();
	} else {
		$(".menubox.mainx").hide();
		$(".menubox.mainy").hide();		
	}
	return {
		GetName: function() { return "Main Delayed Menu"; },
		ButtonPressed: function(nr) {
			switch(nr) {
				case 1:
					if (!this.ShowMenu("sel_m_d")) return;
					osc._maindelayed = !osc._maindelayed;
					if (osc._maindelayed) { osc._maindelayedstr = "X - Y"} else { osc._maindelayedstr = "Main"}
					this.Redraw();
					osc._UpdateDisplay();
					break;
				case 2:
					if (!osc._maindelayed) return;
					if (!this.ShowMenu("sel_m_dx")) return;
					osc._maindelayed_x++;
					if (osc._maindelayed_x > 2) { osc._maindelayed_x = 0 };
					osc.maindelayed_xstr = osc._maindelayed_x + 1;
					if (osc._maindelayed_x == 2) { osc.maindelayed_xstr = "1-2"};
					this.Redraw();
					osc._UpdateDisplay();
					break;
				break;
				case 3:
					if (!osc._maindelayed) return;
					if (!this.ShowMenu("sel_m_dy")) return;
					osc._maindelayed_y++;
					if (osc._maindelayed_y > 2) { osc._maindelayed_y = 0 };
					osc.maindelayed_ystr = osc._maindelayed_y + 1;
					if (osc._maindelayed_y == 2) { osc.maindelayed_ystr = "1-2"};
					this.Redraw();
					osc._UpdateDisplay();
					break;
				break;
			}
			this.Redraw();
		},
		Redraw: function() {
			if (osc._maindelayed) {
				$(".menubox.mainx").show();
				$(".menubox.mainy").show();
			} else {
				$(".menubox.mainx").hide();
				$(".menubox.mainy").hide();		
			}
			$menu.find(".selection").removeClass("selected");
			$menu.find(".sel_m_" + (+osc._maindelayed)).addClass("selected");
			$menu.find(".sel_dx" + osc._maindelayed_x).addClass("selected");
			$menu.find(".sel_dy" + osc._maindelayed_y).addClass("selected");
			$menu.find(".value.mode").text(osc._maindelayedstr);
			$menu.find(".value.dx").text(osc.maindelayed_xstr);
			$menu.find(".value.dy").text(osc.maindelayed_ystr);
		},
		ShowMenu: function(name) {
			this.Redraw();
			this.HideMenu();
			$menu.find(".menu_selection." + name).addClass("visible");
			var menu = this;
			if (!timer) {
				timer = setTimeout(function() { timer=null; menu.HideMenu(); }, 1000);
				return false;
			} else {
				clearInterval(timer);
				timer = setTimeout(function() { timer=null; menu.HideMenu(); }, 1000);
				return true;
			}
		},
		HideMenu: function() {
			$menu.find(".menu_selection").removeClass("visible");
		}
	};
}

function CreateEdgeMenu(osc, $menu)
{
	return {
		GetName: function() { return "Edge Menu"; },
		ButtonPressed: function(nr) {
			switch(nr) {
				case 1:
					// move this to function, we need to update other stuff
					osc._SetTriggerSlope((osc._trigger.slope === "positive") ? "negative" : "positive");
				break;
				case 2:
					osc._SetTriggerSource(1);
				break;
				case 3:
					osc._SetTriggerSource(2);
				break;
			}
			this.Redraw();
		},
		Redraw: function() {
			$menu.find(".edgeselect.selected").removeClass("selected");
			$menu.find(".edgeselect." + osc._trigger.slope).addClass("selected");
			$menu.find(".menubox .value .checkmark").removeClass("selected");
			$menu.find(".menubox .value .checkmark.ch"+ osc._trigger.source).addClass("selected");
		}
	};
}

function CreateTriggerModeCouplingMenu(osc, $menu)
{
	var timer = null;
	return {
		GetName: function() { this.Redraw(); return "Mode / Coupling Menu"; },
		ButtonPressed: function(nr) {
			this.Redraw();
			switch(nr) {
				case 1:
					if (!this.ShowMenu("sel_trigger_mode")) { return; }
					var tmp = osc._triggerModeIdx + 1;
					if (tmp >= osc._triggerModes.length) { tmp = 0; }
					osc._SetTriggerMode(tmp);
				break;
				case 2:
					if (!this.ShowMenu("sel_trigger_coupling")) { return; }
					osc._trigger.coupling = (osc._trigger.coupling === "dc") ? "ac" : "dc";
				break;
			}
			this.Redraw();
		},
		Redraw: function() {
			$menu.find(".selection").removeClass("selected");
			$menu.find(".sel_trigger_mode .sel_" + osc._triggerModes[osc._triggerModeIdx]).addClass("selected");
			$menu.find(".sel_trigger_coupling .sel_" + osc._trigger.coupling).addClass("selected");
			$menu.find(".value.coupling").text(osc._trigger.coupling.toUpperCase());
			$menu.find(".value.mode").text(osc._triggerModesDisplay[osc._triggerModeIdx]);
		},
		ShowMenu: function(name) {
			this.HideMenu();
			$menu.find(".menu_selection." + name).addClass("visible");
			var menu = this;
			if (!timer) {
				timer = setTimeout(function() { timer=null; menu.HideMenu(); }, 1000);
				return false;
			} else {
				clearInterval(timer);
				timer = setTimeout(function() { timer=null; menu.HideMenu(); }, 1000);
				return true;
			}
		},
		HideMenu: function() {
			$menu.find(".menu_selection").removeClass("visible");
		}
	};
}

function CreateMeasurementMenu(osc, $menu)
{
	var timer = null;

	var $sel = $menu.find(".sel_meas_selection");
	for(var i=0;i < osc._measurementInfo.length; i++) {
		var $row = $('<div class="selection"><div class="checkmark_holder"><div class="checkmark"></div></div><span>' + osc._measurementInfo[i].display + '</span></div>');
		$sel.append($row);
	}

	//$sel.find(".selection").first().addClass("selected");
	$sel.find(":nth-child(3)").addClass("selected");

	return {
		GetName: function() { this.Redraw(); return "Measurement Menu"; },
		ButtonPressed: function(nr) {
			this.Redraw();
			switch(nr) {
				case 1:
					if (!this.ShowMenu("sel_meas_source")) return;
					osc._measurementActiveCh = (osc._measurementActiveCh == 1) ? 2 : 1;
				break;
				case 2:
					if (!this.ShowMenu("sel_meas_selection")) return false;
					osc._measurementSelectionIdx++;
					if (osc._measurementSelectionIdx >= osc._measurementInfo.length) osc._measurementSelectionIdx = 0;
				break;

				case 3:
					osc._AddMeasurementAndAnimate(osc._measurementActiveCh, osc._measurementSelectionIdx);
				break;

				case 4:
					osc._ClearMeasurement();
				break;
			}
			this.Redraw();
		},
		Redraw: function() {
			$menu.find(".selection").removeClass("selected");
			$menu.find(".sel_meas_source .sel_" + osc._measurementActiveCh).addClass("selected");
			$menu.find(".sel_meas_selection .selection:nth-child(" + (3 + osc._measurementSelectionIdx) + ")").addClass("selected");
			$menu.find(".value.selection").text(osc._measurementInfo[osc._measurementSelectionIdx].str);
			$menu.find(".value.measure").text(osc._measurementInfo[osc._measurementSelectionIdx].str);
			$menu.find(".value.source").text(osc._measurementActiveCh);
		},
		ShowMenu: function(name) {
			this.Redraw();
			this.HideMenu();
			$menu.find(".menu_selection." + name).addClass("visible");
			var menu = this;
			if (!timer) {
				timer = setTimeout(function() { timer=null; menu.HideMenu(); }, 1000);
				return false;
			} else {
				clearInterval(timer);
				timer = setTimeout(function() { timer=null; menu.HideMenu(); }, 1000);
				return true;
			}
		},
		HideMenu: function() {
			$menu.find(".menu_selection").removeClass("visible");
		}
	};
}

function CreateCursorsMenu(osc, $menu)
{
	var timer = null;
	return {
		GetName: function() { this.Redraw(); return "Cursor Menu"; },
		ButtonPressed: function(nr) {
			this.Redraw();
			switch(nr) {
				case 1:
					// mode
				break;
				case 2:
					// source
				break;
				case 3:
					// x / y
				break;
				case 4:
					// xy1
				break;
				case 5:
					// xy2
				break;
				case 6:
					// xy both
				break;
			}
			this.Redraw();
		},
		Redraw: function() {
		},
		ShowMenu: function(name) {
			this.HideMenu();
			$menu.find(".menu_selection." + name).addClass("visible");
			var menu = this;
			if (!timer) {
				timer = setTimeout(function() { timer=null; menu.HideMenu(); }, 1000);
				return false;
			} else {
				clearInterval(timer);
				timer = setTimeout(function() { timer=null; menu.HideMenu(); }, 1000);
				return true;
			}
		},
		HideMenu: function() {
			$menu.find(".menu_selection").removeClass("visible");
		}
	};
}

function CreateMathMenu(osc, $menu)
{
	var timer = null;
	return {
		GetName: function() { this.Redraw(); return "Math Menu"; },
		ButtonPressed: function(nr) {
			switch(nr) {
				case 1:
				break;
				case 2:
				break;
				case 3:
					osc._math.method = "mul";
				break;
				case 4:
					osc._math.method = "sub";
				break;
				case 5:
					//osc._math.method = "derive";
				break;
				case 6:
					//osc._math.method = "integrate";
				break;
			}
			this.Redraw();
			osc._UpdateDisplay();
		},
		Redraw: function() {
			$menu.find(".menubox .value .checkmark").removeClass("selected");
			$menu.find(".menubox .value .checkmark."+ osc._math.method).addClass("selected");
		},
		ShowMenu: function(name) {
			this.HideMenu();
			$menu.find(".menu_selection." + name).addClass("visible");
			var menu = this;
			if (!timer) {
				timer = setTimeout(function() { timer=null; menu.HideMenu(); }, 1000);
				return false;
			} else {
				clearInterval(timer);
				timer = setTimeout(function() { timer=null; menu.HideMenu(); }, 1000);
				return true;
			}
		},
		HideMenu: function() {
			$menu.find(".menu_selection").removeClass("visible");
		}
	};
}

visir.AgilentOscilloscope.prototype.ReadSave = function($xml) {
	var $oscilloscope = $xml.find("oscilloscope[id='" + this._id + "']");
	if ($oscilloscope.length == 0)
		return;
	
	var timediv = $oscilloscope.attr("timeDiv");
	for (var i = 0; i < this._timedivs.length; ++i) {
		var currentTimeDiv = "" + this._timedivs[i];
		if (currentTimeDiv === timediv) {
			this._SetTimedivIdx(i);
			break;
		}
	}

	for (var i = 0; i < 2; ++i) {
		var $channel = $oscilloscope.find("channel[number='" + (i+1) + "']");
		if ($channel.length == 0)
			continue;
		
		var source = parseInt($channel.attr("number"));
		source = source - 1;

		var currentChannel = this._channels[source];
		currentChannel.xyg = $channel.attr('xyg') === 'true';

		var displayOffset = $channel.attr('display_offset');
		if (displayOffset !== undefined && displayOffset !== null) {
			var displayOffsetValue = Number(displayOffset);
			this._SetDisplayOffset(source, displayOffsetValue);
		}

		var range = $channel.attr('range');

		for (var voltageIndex = 0; voltageIndex < this._voltages.length; voltageIndex++) {
			var currentVoltage = "" + this._voltages[voltageIndex];
			if (currentVoltage === range) {
				this._SetVoltIdx(source, voltageIndex);
				break
			}
		}
	}

	this._UpdateDisplay();
};

visir.AgilentOscilloscope.prototype.WriteSave = function() {
	var $xml = $("<oscilloscope id='" + this._id + "'></oscilloscope>");
	$xml.attr("timeDiv", this._timedivs[this._timeIdx]);

	var $trigger = $("<trigger></trigger>");
	$trigger.attr("source", this._trigger.source);
	$trigger.attr("slope", this._trigger.slope);
	$trigger.attr("coupling", this._trigger.coupling);
	$trigger.attr("level", this._trigger.level);
	$trigger.attr("mode", this._trigger.mode);
	$trigger.attr("timeout", this._trigger.timeout);
	$trigger.attr("delay", this._trigger.delay);
	$xml.append($trigger);

	for (var i = 0; i < 2; i++) {
		var ch = this._channels[i];

		var $channel = $("<channel></channel>");
		$channel.attr("number", i+1);
		$channel.attr("visible", ch.visible);
		$channel.attr("coupling", ch.coupling);
		$channel.attr("display_offset", ch.display_offset);
		$channel.attr("attenuation", ch.attenuation);
		$channel.attr("xyg", ch.xyg);
		$channel.attr("range", ch.range);

		$xml.append($channel);
	}

	return $xml;
};

/*global trace, extend */
/*jshint laxcomma:true, multistr:true */

"use strict";
var visir = visir || {};

visir.NationalInstrumentOscilloscope = function(id, elem, props)
{
	visir.NationalInstrumentOscilloscope.parent.constructor.apply(this, arguments);

	var options = $.extend({
		MeasureCalling: function() {}
		,CheckToContinueCalling: function() { return false; }
	}, props || {});
	this._options = options;

	this._voltages = [5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01, 0.005, 0.002, 0.001];
	this._voltagesDisplay = ["5V", "2V", "1V", "0.5V", "0.2V", "0.1V", "50.0mV", "20.0mV", "10.0mV", "5.0mV", "2.0mV", "1.0mV"];
	this._voltIdx = [2,2];

	this._timedivs = [0.005, 0.002, 0.001, 0.0005, 0.0002, 0.0001, 0.00005, 0.00002, 0.00001, 0.000005, 0.000002, 0.000001, 0.0000005];
	this._timedivsDisplay = ["5.0ms", "2.0ms", "1.0ms", "0.50ms", "0.20ms", "0.10ms", "50.0us", "20.0us", "10.0us", "5.0us", "2.0us", "1.0us", "0.50us"];
	this._timeIdx = 1;

	this._triggerModeIdx = 0;
	//this._triggerLevelUnclamped = 0.0;

	this._isMeasuringContinuous = true;

	var me = this;
	this._$elem = elem;

	this._channels[0].visible = true;
	this._channels[0].display_offset = 0.0;
	this._channels[1].visible = true;
	this._channels[1].display_offset = 0.0;

	var imgbase = "instruments/ni_oscilloscope/images";
	$.get("instruments/ni_oscilloscope/ni_oscilloscope.tpl", function(tpl) {
		tpl = tpl.replace(/%img%/g, imgbase);
		elem.append(tpl);

		var $plot = elem.find(".plot");
		me._plotWidth = $plot.width();
		me._plotHeight = $plot.height();

		me._DrawGrid(elem.find(".grid"));
		me._DrawPlot(elem.find(".plot"));

		elem.find(".graph .offsetbox.ch1").draggable( {
			move: function($elem, x, y) {
				var h = $elem.parent().height();
				if (y < 0) y = 0;
				if (y > h) y = h;
				me._SetDisplayOffset(0, ((y / h) - 0.5) * -8.0);
				return {x: undefined, y: y };
			}
		});

		elem.find(".graph .offsetbox.ch2").draggable( {
			move: function($elem, x, y) {
				var h = $elem.parent().height();
				if (y < 0) y = 0;
				if (y > h) y = h;

				me._SetDisplayOffset(1, ((y / h) - 0.5) * -8.0);
				return {x: undefined, y: y };
			}
		});

		elem.find(".graph .offsetbox.trigger").draggable( {
			move: function($elem, x, y) {
				var h = $elem.parent().height();
				if (y < 0) y = 0;
				if (y > h) y = h;

				var trigch = me._channels[me._trigger.source - 1];
				var level = ((y / h) - 0.5) * -8.0;
				var trig = (((level - trigch.display_offset) * trigch.range) );

				trace("T: " + trig);

				me._SetTriggerLevel(trig);

				//me._SetDisplayOffset(1, ((y / h) - 0.5) * -8.0);
				return {x: undefined, y: y };
			}
		});

		elem.find("select.voltdiv.ch1").change( function(e) { me._SetVoltDivIdx(0, $(this).val()); });
		elem.find("select.voltdiv.ch2").change( function(e) { me._SetVoltDivIdx(1, $(this).val()); });
		elem.find("select.timediv").change( function(e) { me._SetTimeDivIdx($(this).val()); });

		for (var i in me._voltagesDisplay) {
			elem.find(".voltdiv.ch1").append('<option value="'+ i +'"' + (i == me._voltIdx[0] ? 'selected="selected"' : '') +' >' + me._voltagesDisplay[i] + '</option>');
			elem.find(".voltdiv.ch2").append('<option value="'+ i +'"' + (i == me._voltIdx[1] ? 'selected="selected"' : '') +' >' + me._voltagesDisplay[i] + '</option>');
		}
		for (var i in me._timedivsDisplay) {
			elem.find(".timediv").append('<option value="'+ i +'"' + (i == me._timeIdx ? 'selected="selected"' : '') +' >' + me._timedivsDisplay[i] + '</option>');
		}

		me._SetupGraphInteractions();
	});
};

extend(visir.NationalInstrumentOscilloscope, visir.Oscilloscope);

visir.NationalInstrumentOscilloscope.prototype._DrawGrid = function($elem)
{
	var context = $elem[0].getContext('2d');

	//context.strokeStyle = "#004000";
	context.strokeStyle = "#999999";
	context.lineWidth		= 0.5;
	context.beginPath();

	var len = 3.5;
	var w = $elem.width() - 1;
	var h = $elem.height() - 1;
	var xspacing = w / 10;
	var yspacing = h / 8;
	var i, x, y;

	for(i=0;i<=10;i++) {
		x = xspacing * i;
		x = Math.round(x);
		x += 0.5;
		context.moveTo(x, 0);
		context.lineTo(x, h);
	}

	for(i=0;i<=8;i++) {
		y = yspacing * i;
		y = Math.round(y);
		y += 0.5;
		context.moveTo(0, y);
		context.lineTo(w, y);
	}

	context.stroke();
};

visir.NationalInstrumentOscilloscope.prototype._DrawPlot = function($elem)
{
	var context = $elem[0].getContext('2d');
	context.strokeStyle = "#00ff00";
	context.lineWidth		= 1.2;

	var w = this._plotWidth; //$elem.width();
	var h = this._plotHeight; //$elem.height();
	context.clearRect(0,0, w, h);

	var me = this;
	// local draw function
	function DrawChannel(chnr, color) {
		if (!me._channels[chnr].visible) { return; }
		context.beginPath();
		context.strokeStyle = color;
		var ch = me._channels[chnr];
		var graph = ch.graph;
		var len = graph.length;
		for(var i=0;i<len;i++) {
			var x = i*w / len;
			var y = -((graph[i] / ch.range) + ch.display_offset) * (h / 8.0) + h/2;
			y+=0.5;
			if (i===0) {
				context.moveTo(x,y);
			} else {
				context.lineTo(x,y);
			}
		}
		context.stroke();
	}

	DrawChannel(1, "#9095f9");
	DrawChannel(0, "#FFFFFF");
};

visir.NationalInstrumentOscilloscope.prototype.ReadResponse = function(response) {
	visir.NationalInstrumentOscilloscope.parent.ReadResponse.apply(this, arguments);
	this._DrawPlot(this._$elem.find(".plot"));

	// check if we should continue measuring
	if (this._isMeasuringContinuous && this._options.CheckToContinueCalling()) {
		this._options.MeasureCalling();
	} else {
		this._isMeasuringContinuous = false;
	}
};

visir.NationalInstrumentOscilloscope.prototype._SetDisplayOffset = function(ch, offset) {
	this._channels[ch].display_offset = offset;
	this._channels[ch].offset = this._voltages[this._voltIdx[ch]] * -this._channels[ch].display_offset;
	//trace("_SetDisplayOffset: " + offset + " " + this._channels[ch].offset);

	this._DrawPlot(this._$elem.find(".plot"));
	this._UpdateTrigger();
};

visir.NationalInstrumentOscilloscope.prototype._UpdateTrigger = function() {
	var $trigger = this._$elem.find(".offsetbox.trigger");
	var h = $trigger.parent().height();

	var trigch = this._channels[this._trigger.source - 1];
	var level = this._trigger.level;

	var markerPos = (((-level + trigch.offset) / trigch.range) ) * (h / 8.0) + (h / 2.0);
	markerPos = Math.round(markerPos);
	$trigger.css("top", markerPos + "px");
};

visir.NationalInstrumentOscilloscope.prototype._SetTriggerLevel = function(level) {
	this._trigger.level = level;
}

visir.NationalInstrumentOscilloscope.prototype._SetVoltDivIdx = function(ch, idx) {
	if (idx < 0) idx = 0;
	if (idx >= this._voltages.length) idx = this._voltages.length - 1;
	trace("_SetVoltDivIdx: " + ch + " " + idx);

	this._voltIdx[ch] = idx;
	this._channels[ch].range = this._voltages[idx];
	this._channels[ch].offset = this._voltages[idx] * -this._channels[ch].display_offset;
	this._UpdateTrigger();
	this._DrawPlot(this._$elem.find(".plot"));
	this._$elem.find("select.voltdiv.ch" + (ch+1)).val(idx);
}

visir.NationalInstrumentOscilloscope.prototype._SetTimeDivIdx = function(idx) {
	if (idx < 0) idx = 0;
	if (idx >= this._timedivs.length) idx = this._timedivs.length - 1;

	trace("_SetTimeDivIdx: " + idx);

	this._timeIdx = idx;
	this._sampleRate = 1.0 / this._timedivs[this._timeIdx];
	this._DrawPlot(this._$elem.find(".plot"));
	this._$elem.find("select.timediv").val(idx);
}

visir.NationalInstrumentOscilloscope.prototype._SetupGraphInteractions = function()
{
	var me = this;
	var timer = null;

	/*
		make mouse wheel scrolling zoom the current channel
		if horizontal scroll is available, it will change the time div
	*/
	this._$elem.find(".clickarea").on("mousewheel", function(e) {
		trace("mousewheel");
		e.preventDefault();
		var deltaY = e.originalEvent.wheelDeltaY; // non portable?
		var deltaX = e.originalEvent.wheelDeltaX; // non portable?

		if (Math.abs(deltaY) > Math.abs(deltaX)) deltaX = 0;
		else deltaY = 0;

		// don't allow more than one scroll event per half-second
		if (timer) return false;
		timer = setTimeout(function() { clearInterval(timer); timer = null; }, 500);

		if (deltaY > 0) {
			me._SetVoltDivIdx(0, me._voltIdx[0] + 1);
		} else if (deltaY < 0) {
			me._SetVoltDivIdx(0, me._voltIdx[0] - 1);
		}

		if (deltaX > 0) {
			me._SetTimeDivIdx(me._timeIdx - 1);
		} else if (deltaX < 0) {
			me._SetTimeDivIdx(me._timeIdx + 1);
		}

	});

	/*
		Make two finger interaction on the graph work as pinch zoom in and out.
	*/
	var me = this;
	var $touch = this._$elem.find(".clickarea");
	$touch.on("gesturestart", function(e) {
		e.preventDefault();

		var deg = 0;

		$touch.on("touchmove.rem", function(e) {
			if (e.originalEvent.touches && e.originalEvent.touches < 2) return;
			var t1 = e.originalEvent.touches[0];
			var t2 = e.originalEvent.touches[1];
			if (t2.pageY < t1.pageY) {
				var tmp = t1;
				t1 = t2;
				t2 = tmp;
			}
			var dx = t2.pageX - t1.pageX;
			var dy = t2.pageY - t1.pageY;
			deg = Math.atan2(dy, dx) * 180 / Math.PI;
		});

		$touch.on("gestureend.rem", function(e) {
			$touch.off(".rem");

			//if (timer) return false;
			//timer = setTimeout(function() { clearInterval(timer); timer = null; }, 500);

			var scale = e.originalEvent.scale;
			var rot = e.originalEvent.rotation;
			trace(new Date().getTime() + " scale: " + scale + " " + rot + " " + deg);

			var cutoff= 35;
			if ((deg > 180 - cutoff) || (deg < cutoff)) {
				trace("horizontal");
				if (scale > 1.4) me._SetTimeDivIdx(me._timeIdx + 1);
				else if (scale < 0.6) me._SetTimeDivIdx(me._timeIdx - 1);
			}
			else {
				trace("vertical");
				if (scale > 1.4) me._SetVoltDivIdx(0, me._voltIdx[0] + 1);
				else if (scale < 0.6) me._SetVoltDivIdx(0, me._voltIdx[0] - 1);
			}
		});

		//var scale = e.originalEvent.scale;
		//trace("scale: " + scale);

		/*if (timer) return false;
		timer = setTimeout(function() { clearInterval(timer); timer = null; }, 500);

		//var scale = e.originalEvent.scale;
		//trace("scale: " + scale);

		if (scale > 1.2) {
			me._SetVoltDivIdx(0, me._voltIdx[0] + 1);
		} else if (scale < 0.8) {
			me._SetVoltDivIdx(0, me._voltIdx[0] - 1);
		}*/
	});
}
/* This is tightly dependent on the InstrumentRegistry, so make sure not to break the storage format */

var visir = visir || {};

visir.InstrumentFrame = function(instreg, transport, $container)
{
	this._registry = instreg;
	this._$container = $container;
	this._transport = transport;

	var frame = this;

	this._showingInstrumentDialog = false;

	var imgbase = "instrumentframe";
	if (visir.BaseLocation) imgbase = visir.BaseLocation + imgbase;
	this._baseurl = imgbase;

	//XXX: should generate a iframe name with a unique id..
	var tpl = '<div class="frame">\
	<div style="display: none">\
		<input id="upload" name="filename" type="file" accept=".cir" />\
		<input type="hidden" id="download_data" name="data" />\
	</div>\
	<div class="bottomaligner">\
		<div class="container">\
			<div class="instrumentdialog">\
				<div class="instrumentlist"></div>\
			</div>\
		</div>\
	</div>\
	<div class="buttonrow">\
		' + (!visir.Config.Get("readOnly") ?
		'<div class="loadsave">\
			<button id="loadbutton" class="">'+visir.Lang.GetMessage('load')+'</button>\
			<button id="savebutton" class="">'+visir.Lang.GetMessage('save')+'</button>\
		</div>\
		<div class="shelf"><button id="shelfbutton"><img src="%img%/images/shelf.png" /></button></div>\
		' : '') + // XXX: hard to read this maybe insert after instead
		'<div class="instrumentbuttons"></div>\
		<div class="measurework">\
			<button id="measurebutton" class="measure">'+visir.Lang.GetMessage('perf_measure')+'</button>\
			<div class="work_indicator"><span><img src="%img%/images/work_indicator.png" alt="work indicator"/></span></div>\
		</div>\
	</div>\
	</div>\
	';

	tpl = tpl.replace(/%img%/g, imgbase);
	var $tpl = $(tpl);

	var isTouchDevice = navigator.userAgent.match(/iPhone|iPad/);

	$container.append($tpl);

	var $loadsave = $container.find(".loadsave");
	if (visir.Config.Get("disableLoadSave")) {
		$loadsave.remove();
		$('.shelf').css({'margin-left': '10px'});
	}

	var teacher_mode = (visir.Config) ? visir.Config.Get("teacher") : true;
	if (teacher_mode) {
		this._$container.find("div.shelf").addClass("show");
	}

	if (isTouchDevice) {
		var $dialog = $('\
		<div class="filedialog">\
			<div class="loaddialog dialog"><div class="closebutton"></div><div class="files"></div></div>\
			<div class="savedialog dialog"><div class="closebutton"></div>\
				<div>Enter file name:</div>\
				<input id="filename" type="text" />\
				<br/><button id="save">Save</button>\
				<div class="infotext">Files on portable devices are stored in the browsers local storage and will be removed if the browsers data store is cleared.</div>\
			</div>\
		</div>\
		');

		$dialog.find(".savedialog button#save").click( function() {
			var filename = $dialog.find(".savedialog input#filename").val();
			if (!filename) {
				alert("Please enter a valid filename");
				return;
			}
			frame._SaveToLocalStorage(filename);
			$dialog.find(".dialog").hide();
		});

		$dialog.find(".closebutton").click( function() {
			$dialog.find(".dialog").hide();
		});

		this._$container.find(".container").append($dialog);
	}
	instreg.AddListener( { onExperimentLoaded: function() { frame.CreateButtons(); }  })

	$container.find("#savebutton").click( function() {
		if (!isTouchDevice) {
			frame._SaveToFileSystem();
		} else {
			frame._ShowLocalStorageSaveDialog();
		}
	});

	$container.find("#loadbutton").click( function() {
		if (!isTouchDevice) {
			frame._LoadFromFileSystem();
		} else {
			frame._ShowLocalStorageLoadDialog();
		}
	});

	$container.find("#shelfbutton").click( function() {
		frame.ShowInstrumentSelection(! frame._showingInstrumentDialog);
	});

	$container.find("#upload").change( function(evt) {
		circuit = this._transport.LoadCircuit(evt.target.files[0], function(circuit) {
			trace("loaded: '" + circuit + "'");

			instreg.LoadExperiment(circuit, $container.find(".container"));
			$container.find("#upload").val(""); // trick to make sure we get the change request even if the same file was selected
		});
	}.bind(this));

	this.ShowWorkingIndicator(false);

	var me = this;

	$("body").on("working", function(e) { me.ShowWorkingIndicator(e.isWorking); });

	/// Note: the .measure button click is handled outside this class
}

visir.InstrumentFrame.prototype._SaveToFileSystem = function()
{
	this._transport.SaveCircuit(this._registry.WriteSave(true));
}

visir.InstrumentFrame.prototype._LoadFromFileSystem = function()
{
	this._$container.find("#upload").click();
}

visir.InstrumentFrame.prototype._ShowLocalStorageSaveDialog = function()
{
	this._$container.find(".dialog").hide();
	this._$container.find(".savedialog").show();
}

visir.InstrumentFrame.prototype._ShowLocalStorageLoadDialog = function()
{
	var me = this;
	var data = JSON.parse(window.localStorage.getItem("savedata")) || {};

	this._$container.find(".filedialog .loaddialog .files").empty();

	var empty = true;

	for(var key in data) {
		empty = false;

		var $file = $('<div class="file"><div class="filename">' + key + '</div><div class="delete"></div></div>');

		function genLoadFunc(loaddata) {
			return function() {
				trace("clicked load");
				me._registry.LoadExperiment(loaddata, me._$container.find(".container"));
				me._$container.find(".dialog").hide();
			}
		}

		$file.find(".filename").click(genLoadFunc(data[key]));

		function genDeleteFunc(data, filename) {
			return function() {
				var answer = confirm("Are you sure you want to delete this file?");
				if (answer) {
					// delete the file
					delete data[filename];
					window.localStorage.setItem("savedata", JSON.stringify(data));
					return me._ShowLocalStorageLoadDialog();
				}
			}
		}

		$file.find(".delete").click(genDeleteFunc(data, key));

		this._$container.find(".filedialog .loaddialog .files").append($file);
	}

	if (empty) {
		this._$container.find(".filedialog .loaddialog .files").append('<div class="infotext">No saved files</div>');
	}

	this._$container.find(".dialog").hide();
	this._$container.find(".loaddialog").show();
}

visir.InstrumentFrame.prototype._SaveToLocalStorage = function(name)
{
	if (!window.localStorage) alert("browser doesn't support local storage");
	var save = this._registry.WriteSave();
	trace("save to local storage");
	trace(save);

	var data = JSON.parse(window.localStorage.getItem("savedata")) || {};
	if (data[name]) {
		if (!confirm("Overwrite existing file?")) return;
	}
	data[name] = save;
	window.localStorage.setItem("savedata", JSON.stringify(data));
}

visir.InstrumentFrame.prototype._LoadFromLocalStorage = function(name)
{
	if (!window.localStorage) alert("browser doesn't support local storage");
	var loaddata = window.localStorage.getItem("savedata:0");
	trace("load from local storage");
	if (!loaddata) {
		alert("local storage data not found");
		return;
	}
	trace(loaddata);
	this._registry.LoadExperiment(loaddata, this._$container.find(".container"));
}

visir.InstrumentFrame.prototype.GetInstrumentContainer = function()
{
	return this._$container.find(".container");
}

visir.InstrumentFrame.prototype._CreateInstrButton = function(name)
{
	return $('<div class="buttonctnr"><button class="instrumentbutton">' + name + '</button><div class="closebutton"></div></div>');
}

visir.InstrumentFrame.prototype.CreateButtons = function()
{
	var instruments = this._registry._instruments; // watch out!

	this._$container.find(".buttonctnr").remove();
	var me = this;

	function genButtonHandler($dom) {
		return function() {
			for(var i=0;i<instruments.length; i++) {
				instruments[i].domnode.hide();
			}
			$dom.show();
			// don't continue continous measurements when we switch instruments
			$("body").trigger( { type:"working", isWorking: false, shouldContinue: false });
		}
	}

	function genCloseButtonHandler($btnctnr, instr) {
		return function() {
			me._registry.RemoveInstrument(instr);
			$btnctnr.remove(); // remove this button
			me.ShowFirstInstrument();
			$("body").trigger("configChanged"); // notify so we can update instrument connections
		}
	}

	for(var i=0;i<instruments.length; i++) {
		var instr = instruments[i];
		var suffix = "";
		if (instruments[i].id > 1) suffix += " " + instruments[i].id;
		var $newButton = this._CreateInstrButton( instr.instrInfo.displayname + suffix);
		$newButton.find(".instrumentbutton").click( genButtonHandler(instr.domnode));
		$newButton.find(".closebutton").click( genCloseButtonHandler($newButton, instruments[i]));
		this._$container.find(".instrumentbuttons").append($newButton);
	}

	this.ShowFirstInstrument();
}

visir.InstrumentFrame.prototype.ShowFirstInstrument = function()
{
	this._$container.find(".container > .instrument").hide();
	this._$container.find(".container > .instrument").first().show();
}

visir.InstrumentFrame.prototype.ShowWorkingIndicator = function(show)
{
	this._$container.find(".work_indicator img").toggle(show);
}

visir.InstrumentFrame.prototype._PopulateInstrumentDialog = function()
{
	var url = this._baseurl + "/instruments.xml";

	var $list = this._$container.find(".instrumentlist");
	$list.empty();

	var me = this;

	$.get(url, function(rawxml) {
		var $xml = $(rawxml);
		trace("instrument library loaded");
		$xml.find("instruments > instrument").each( function(e) {
			var $elem = $(this);
			var id = $elem.attr("id");
			var displayname = visir.Lang.GetDescription($elem.attr("displayname"));
			var type = $elem.attr("type");
			var image = $elem.attr("image");
			var path = $elem.attr("path"); // this is the swf path, do not use
			var jsclass = $elem.attr("jsclass");

			var elem = '<div class="list-elem"><img src="%img%/' + image + '" /><div class="title">' + displayname + '</div></div>';
			elem = elem.replace(/%img%/g, me._baseurl);
			var $elem = $(elem);
			$elem.click(function(e) {
				trace("moot!");
				if (me._registry._instruments.length >= 6) return;
				me._registry.CreateInstrFromJSClass(jsclass, me._$container.find(".container"));
				me.CreateButtons();
				me._$container.find(".instrumentbuttons .closebutton").show();
				$("body").trigger("configChanged"); // notify so we can update instrument connections
			});

			$list.append($elem);
		});
	});
}

visir.InstrumentFrame.prototype.ShowInstrumentSelection = function(show)
{
	this._showingInstrumentDialog = show;
	if (show) {
		this._PopulateInstrumentDialog();
		//this._$container.find("div.shelf").toggleClass("show");
		this._$container.find(".instrumentdialog").show();
		this._$container.find(".instrumentbuttons .closebutton").show();
	} else {
		this._$container.find(".instrumentdialog").hide();
		this._$container.find(".instrumentbuttons .closebutton").hide();
	}
}

visir.InstrumentFrame.prototype.ShowDeleteButtons = function(show)
{
	this._$container.find(".instrumentbuttons .closebutton").toggleClass("show");
}
